# 选择

## 	大量的，博弈论

​		两堆石头，先手后手怎么赢



# 算法

## 	求log10(n)



## 	坐标系求“廿”的坐标绝对值之和，满足输入M的个数



## 	求无向图，消除一节点，使得存在任意两个节点无法被其他节点访问到

思路：染色法



## 从（0，0）开始，向右下角（M-1，N-1）出发，上下右三个方向，不能走已经走过的路，最大值为多少（每个坐标的值有正有负）

思路：染色法+动态规划，TMD血的教训，一定要注意**List的复制是地址复制！！！地址复制！！！地址复制！！！！！**

```python
# coding=utf-8
import sys

if __name__ == "__main__":
    M, N = sys.stdin.readline().strip().split()
    _in = [[] for _ in range(int(N))]
    for i in range(int(N)):
        _in[i] = sys.stdin.readline().strip().split()
    # print(_in)
    dp = _in
    dp2 = [[0]*int(M) for _ in range(int(N))]

    # 0 未走，1上，2下，3右
    def deepin(i, j, score, last=0):
        dp2[i][j] = "sss"
        score += int(dp[i][j])
        up = -10000000000
        down = -1000000000
        right = -1000000000
        if i == int(N) - 1 and j == int(M) - 1:
            return dp[i][j]
        # 上边缘
        if last != 1:
            if i == 0:
                if dp2[int(N)-1][j]!="sss":
                    up = deepin(int(N) - 1, j, 0, 1) - score
            else:
                if dp2[i-1][j]!="sss":
                    up = score + int(deepin(i - 1, j, score, 1))
        # 右边缘
        if last != 3:
            if j == int(M) - 1:
                # right = deepin(i, 0, 0,3)
                return score
            else:
                if dp2[i][j+1]!="sss":
                    right = score + int(deepin(i, j + 1, score, 3))
        # 下边缘
        if last != 2:
            if i == int(N) - 1:
                if dp2[0][j]!= "sss":
                    down = deepin(0, j, 0, 2) - score
            else:
                if dp2[i+1][j]!="sss":
                    down = score + int(deepin(i + 1, j, score, 2))
        return max(up, right, down)


    print(deepin(0, 0, int(_in[0][0])))

```

