# [一、排序算法]()



## 冒泡排序

最优时间复杂度：O(n)

最坏时间复杂度：O(n^2)

平均时间复杂度：O(n^2)

空间复杂度：O(1)

```python
# 冒泡排序
def maopao(_list):
    for i in range(len(_list) - 1):
        end = 0
        for j in range(len(_list) - 1 - end):
            if _list[j] > _list[j+1]:
                temp = _list[j]
                _list[j] = _list[j+1]
                _list[j+1] = temp
                end = j
        if end == 0:
            return _list
```





## 选择排序(不稳定)

最优时间复杂度：O(n^2)

最坏时间复杂度：O(n^2)

平均时间复杂度：O(n^2)

空间复杂度：O(1)

```python
# 选择排序
def xuanze(_list):
    for i in range(len(_list)):
        min = i
        for j in range(i, len(_list)):
            if _list[j] <= _list[min]:
                min = j
        _list.insert(i, _list[min])
        _list.pop(min + 1)
    return _list
```





## 插入排序

最优时间复杂度：O(n)

最坏时间复杂度：O(n^2)

平均时间复杂度：O(n^2)

空间复杂度：O(1)

```python
# 插入排序
def charu(_list):
    for i in range(1, len(_list)):
        for j in range(i, 0, -1):
            if _list[j] < _list[j-1]:
                temp = _list[j]
                _list[j] = _list[j-1]
                _list[j-1] = temp
    return _list
```





## 希尔排序(不稳定)

最优时间复杂度：O(n log^2 n)

最坏时间复杂度：O(n log^2 n)

平均时间复杂度：O(n log n)

空间复杂度：O(1)

```python
# 希尔排序
def shell(_list):
    m = (len(_list)/2).__ceil__()  # 天花板
    while m >= 1:
        for i in range(len(_list) - m):
            if _list[i] >= _list[m+i]:
                _list[i], _list[m+i] = _list[m+i], _list[i]
        if m == 1:
            break
        m = (m/2).__ceil__()
    return _list
```





## 归并排序

最优时间复杂度：O(n log n)

最坏时间复杂度：O(n log n)

平均时间复杂度：O(n log n)

空间复杂度：O(n)

```python
# 归并排序
def merge(_list, l, m, r):
    copyList = list(_list[:])
    i, j = l, m+1
    for k in range(l,r+1):
        if i > m:
            _list[k] = copyList[j]
            j += 1
        elif j > r:
            _list[k] = copyList[i]
            i += 1
        elif copyList[i] < copyList[j]:
            _list[k] = copyList[i]
            i += 1
        else:
            _list[k] = copyList[j]
            j += 1

def mergeSort(_list, l, r):
    if l >= r:
        return
    m = int((l+r)/2)
    mergeSort(_list, l, m)
    mergeSort(_list, m+1, r)
    # if _list[m] > _list[m+1]:
    merge(_list, l, m, r)
```

思想：先将数列分割成若干组，再从小到大不断进行排序合并，最终形成一个大的排序好的数列





## 快速排序(不稳定)

最优时间复杂度：O(n log n)

最坏时间复杂度：O(n^2)

平均时间复杂度：O(n log n)

空间复杂度：O(1)

```python
# 快排
def kuaipai(_list, start, end):
    if start < end:
        middle = searchAndSort(_list, start, end)
        kuaipai(_list, start, middle - 1)
        kuaipai(_list, middle + 1, end)


def searchAndSort(_list, start, end):
    i = start - 1
    X = _list[end]  # 标兵
    for j in range(start, end - 1):
        if _list[j] <= X:
            i += 1
            _list[j], _list[i] = _list[i], _list[j]
    _list[end], _list[i + 1] = _list[i + 1], _list[end]
    return i + 1
```





## 堆排序(不稳定)

最优时间复杂度：O(n log n)

最坏时间复杂度：O(n log n)

平均时间复杂度：O(n log n)

空间复杂度：O(1)

```python
# 堆排序
def heap_sort(_list):
    def sift_down(start, end):
        """最大堆调整"""
        """通过输入的子树的不断调整，使得根节点保持最大"""
        root = start
        while True:
            child = 2 * root + 1
            if child >= end:
                break
            if child + 1 < end and _list[child] < _list[child + 1]:
                child += 1
            if _list[root] < _list[child]:
                _list[root], _list[child] = _list[child], _list[root]
                root = child
            else:
                break

    # 創建最大堆（根节点最大）
    for start in range((len(_list) - 2) // 2, -1, -1):
        sift_down(start, len(_list))

    # 堆排序（将最大值移到最后的节点，然后剩余节点继续调整最大堆）
    for end in range(len(_list) - 1, 0, -1):
        _list[0], _list[end] = _list[end], _list[0]
        sift_down(0, end - 1)
    return _list
```

思想：

1）堆存储在数组中，索引从0开始

2）左孩子：2*i + 1；右孩子：2\*i + 2；父节点：[(i-1)/2]

3）第一个非叶子节点：[(n-2)/2]

不断重复：剩余节点调整最大堆->移动最大节点到末尾



## 计数排序

最优时间复杂度：O(n+k)

最坏时间复杂度：O(n+k)

平均时间复杂度：O(n+k)

空间复杂度：O(k)

```python
def countSort(_list):
    outList = []
    numList = [0]*(max(_list)+1)
    for i in range(len(_list)):
        numList[_list[i]] += 1
    for i in range(len(numList)):
        if numList[i]:
            for _ in range(numList[i]):
               outList.append(i)
    return outList
```

思想：非比较型排序、只适合整型





## 桶排序

最优时间复杂度：O(n+k)

最坏时间复杂度：O(n^2)

平均时间复杂度：O(n+k)

空间复杂度：O(n+k)

```python
def bucket_sort(_list):
    min_num, max_num = min(_list), max(_list)
    # 划分桶
    bucket_num = (max_num-min_num)//3 + 1
    buckets = [[] for _ in range(int(bucket_num))]
    # 数据入桶
    for num in _list:
        buckets[int((num-min_num)//3)].append(num)
    new_list = list()
    for i in buckets:
        # 其他排序方法，排序桶内数据
        for j in sorted(i):
            new_list.append(j)
    return new_list
```

思想：划分固定区间（桶），将数据放入区间，再在桶内部进行排序，最终合并各区间





## 基数排序

最优时间复杂度：O(n*k)

最坏时间复杂度：O(n*k)

平均时间复杂度：O(n*k)

空间复杂度：O(n+k)

```python
# 基数排序
def radix_sort(_list):
    n = len(str(max(_list)))  # 记录最大值的位数
    for k in range(n):#n轮排序
        # 每一轮生成10个列表
        bucket_list=[[] for i in range(10)]#因为每一位数字都是0~9，故建立10个桶
        for i in _list:
            # 按第k位放入到桶中
            bucket_list[i//(10**k)%10].append(i)
        # 按当前桶的顺序重排列表 先进先出原则
        _list=[j for i in bucket_list for j in i]
    return _list
```

思想：从低位数到高位数，取出位数上的值，分轮排序，适用于整型





# 二、查找算法

## 二分查找

```python
def binarySearch(_list, target):
    l = 0
    r = len(_list)-1
    m = int((r+l)/2)
    while l <= r:
        if _list[m] < target:
            l = m + 1
            m = int((l+r)/2)
        elif _list[m] > target:
            r = m - 1
            m = int((l+r)/2)
        else:
            return m
    return
```

思路：每次折半查找，数列要事先排好序





# 三、一些特殊算法



## 组合数问题

### 卡特兰数

形如：1， 1，2， 5， 14， 42·······的数列或规律

其递推关系式为：![img](https://bkimg.cdn.bcebos.com/formula/de5283a6c45936d756a6fe53563e6b8b.svg)

统一解集：C(2 n, n) - C(2 n,  n-1) 

例子：

​	卖票问题：2 n人，n人5￥，n人10￥，门票5￥，多少种排列方式使得10￥到达就有5￥找?（可视为出栈入栈）

​	出栈问题：一个栈(无穷大)的进栈序列为1,2,3,..n,有多少个不同的出栈序列?

​	二叉树构造问题：给定N个节点，能构成多少种不同的二叉树?

​	**矩阵链乘**： P=a 1×a 2×a 3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(h(n)种) 

```python
# 递归：卡特兰数
class Solution:
    def Katelan(self, n):
        """
        :n: int
        """
        if n == 0:
            return 1
        if n == 1:
            return 1
        res = 0
        for i in range(0, n):
            res += self.Katelan(n-i-1)*self.Katelan(i)
        return res
```



### 斐波拉契数列

形如：1，1，2，3，5，8，13······的数列或规律，又称黄金分割数列。

其递推关系式为：![img](https://bkimg.cdn.bcebos.com/formula/016c959089b85f38f460f9e037f50216.svg)

例子：

​	塔罗骨牌的填充方式（塔罗骨牌有n*2个，每次可以横向填充两个，或者纵向填充两个，问有几种填充方式）

```python
# 递归：斐波拉契
class Soulution:
    def Fibonacci(slef, n):
        """
        :n: int
        """
        if n == 0:
            return 1
        elif n == 1:
            return 1
        return slef.Fibonacci(n-1)+slef.Fibonacci(n-2)
```



## DFS算法

深度搜索算法，深度优先算法

leetcode例题：https://leetcode.cn/problems/generate-parentheses/

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合（结果个数满足卡特兰数）。

```python
# 思路：dfs 深度优先算法
class Solution(object):
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """

        def rev(a, b, ans):
            if a == n and b == n - 1:
                res.append(ans + ')')
                return
            if a < n:
                rev(a + 1, b, ans + "(")
            if b < a:
                rev(a, b + 1, ans + ")")

        if n == 0:
            return []
        res = []
        rev(1, 0, '(')
        return res
```



## 动态规划dp

leetcode例题：https://leetcode.com/problems/house-robber/

有一排房子，每间房子金额不同，连续两间房之间只能抢一个，问最多能抢多少？

```python
# 动态规划
class Soulution:
    def robber(slef, _list):
        if len(_list) == 0:
            return 0
        dp = []
        dp.append(0)
        dp.append(_list[0])
        for i in range(1, len(_list)):
            dp.append(max(dp[i], dp[i - 1] + _list[i]))
        return dp[len(_list)]
```

思路：每个房子有抢和不强两种状态，下个房子抢不抢取决于上上个房子的价值加下个房子的价值，是否高于本房子的价值



## 贪心算法

贪心算法：每次选择当前最优，适用于局部最优可取代全局最优

leetcode例题：[11. 盛最多水的容器 - 力扣（LeetCode）](https://leetcode.cn/problems/container-with-most-water/)

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

```python
# 贪心算法：局部最优
class Solution(object):
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        l = 0
        r = len(height) - 1
        area = 0
        while l < r:
            area = max(area, min(height[l], height[r]) * (r - l))
            minH = min(height[l], height[r])  # 记录当前的高度，如果改变后高度不如找个，那么不改变
            # 节省时间的直接缩短区间
            while height[l] <= minH and l < r:
                l += 1
            while height[r] <= minH and l < r:
                r -= 1
        return area


if __name__ == '__main__':
    print(Solution().maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7]))

```



## 染色法

要判断一个图是不是二分图，可以用两种颜色对图上的所有结点进行染色。

染色法的基本思路是，如果一个图是二分图，那么一个结点所连接的所有结点都一定和这个结点属于不同侧，也就应该染上不同的颜色。

所以只要先将一个结点染成颜色1 11，然后检查它的所有邻接结点j jj。

如果j jj已经染过颜色了，而且和本结点的颜色一样，那么就发生了冲突，说明不能形成二分图。
如果j jj结点没有染过颜色，就将其染成和自己这个结点颜色不一样的（比如自己是1 11，那么就把j jj结点染色成2 22），这是一个递归的过程，如果这个过程中发生了冲突，就说明不能形成二分图，将这个信息向上传递
以下代码为模板题代码：

```java
import java.util.*;


public class Main {
    private static int n, m;

    private static int h[], e[], ne[], idx;

    private static void add_edge(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx++;
    }

    private static int color[];

    private static boolean dfs(int u, int c) {
        color[u] = c;
        for (int i = h[u]; i != -1; i = ne[i]) {
            int j = e[i];
            if (0 == color[j]) {
                if (!dfs(j, 3 - c)) return false;
            } else if (c == color[j]) return false;
        }
        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        m = scanner.nextInt();
		// 初始化颜色数组
        h = new int[n + 10];
        for (int i = 1; i <= n; i++) h[i] = -1;
        
        e = new int[2 * m + 10];
        ne = new int[2 * m + 10];
        idx = 0;

        for (int i = 0; i < m; i++) {
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            add_edge(a, b);
            add_edge(b, a);
        }

        boolean t = true;
        color = new int[n + 10];
        for (int i = 1; i <= n; i++) {
            if (0 == color[i]) {
                if (!dfs(i, 1)) {
                    t = false;
                    break;
                }
            }
        }
        if (t) System.out.println("Yes");
        else System.out.println("No");
    }
}
```



例题：[886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/)

```python
# python3方法
# 深度优先：先遍历全部人、再遍历每个人的不喜欢的人
class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        def dfs(i, c):
            color[i] = c
            for j in g[i]:
                # 不喜欢的人和他相同颜色了！False
                if color[j] == c:
                    return False
               	# 不喜欢的人还没有标记颜色！同时继续迭代发现有不喜欢的人和他有相同颜色！False
                if color[j] == 0 and not dfs(j, 3 - c):
                    return False
            # 没有发现错误！True
            return True	

        g = defaultdict(list)
        # 初始化颜色数组
        color = [0] * n
        # 字典存储互不喜欢的关系
        for a, b in dislikes:
            a, b = a - 1, b - 1
            g[a].append(b)
            g[b].append(a)
        
        return all(c or dfs(i, 1) for i, c in enumerate(color))
    
    
# python 方法
# 一定要活用迭代
from collections import defaultdict
class Solution(object):
    def possibleBipartition(self, n, dislikes):
        """
        :type n: int
        :type dislikes: List[List[int]]
        :rtype: bool
        """
        def dfs(i, c):
            color[i] = c
            for m in ds[i]:
                # 颜色相同，False
                if color[m] == c:
                    return False
                # 未染色，继续迭代，发现颜色相同的互斥对，Fasle
                elif color[m] == 0 and not dfs(m, 3 - c):
                    return False
            # 什么都没发现， True
            return True

        ds = [[] for _ in range(n)]
        for i, j in dislikes:
            ds[i-1].append(j-1)
            ds[j-1].append(i-1)
        color = [0]*n  # 0表示未标记，1表示左，2表示右

        # 什么意思？（列表内全部数据均为真（>0））
        # return all(c or dfs(i, 1) for i, c in enumerate(color))

        for i in range(n):
            # 已经染色过了，跳过
            if color[i] != 0:
                continue
            # 未染色过，赋值为1，开始迭代
            if not dfs(i, 1):
                return False
        return True
    
# 测试用例
if __name__ == '__main__':
    print(Solution().possibleBipartition(4, [[1, 2], [1, 3], [2, 4]]))
    print(Solution().possibleBipartition(3, [[1, 2], [1, 3], [2, 3]]))
    print(Solution().possibleBipartition(5, [[1, 2], [2, 3], [3, 4], [4, 5], [1, 5]]))
    print(Solution().possibleBipartition(10, [[1, 2], [3, 4], [5, 6], [6, 7], [8, 9], [7, 8]]))


```



## [并查集](http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure/)

```python
# 并查集模板
p = list(range(n))
size = [1] * n

def find(x):
    if p[x] != x:
        # 路径压缩
        p[x] = find(p[x])
    return p[x]


def union(a, b):
    pa, pb = find(a), find(b)
    if pa == pb:
        return
    p[pa] = pb
    size[pb] += size[pa]
```

例题：[886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/)

```python
class Solution:
    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        def find(x):
            if p[x] != x:
                p[x] = find(p[x])
            return p[x]

        g = defaultdict(list)
        for a, b in dislikes:
            a, b = a - 1, b - 1
            g[a].append(b)
            g[b].append(a)
        p = list(range(n))
        for i in range(n):
            for j in g[i]:
                if find(i) == find(j):
                    return False
                p[find(j)] = find(g[i][0])
        return True
```



# 四、链表

```python
# 链表定义
class Node(object):
    def __init__(self, val, next=None):
        self.val = val
        self.next = next
```



## 单链表翻转

```python
# 非递归算法
def reverseNode(node):
    if not node:
        return node
    pre = None  # 保证头节点翻转后为空
    temp = None
    while node:
        temp = node.next
        node.next = pre
        pre = node
        node = temp
    return pre

# 程序入口
if __name__ == '__main__':
    _list = [1, 2, 3, 4]
    root = Node()
    head = root
    for i in _list:
        if not root.val:
            root.val = i
        else:
            node = Node(i)
            root.next = node
            root = node
    out_head = reverseNode(head)
    while out_head:
        print(out_head.val)
        out_head = out_head.next
```

```python
# 递归算法
def reverseNode(node):
    if not node or not node.next:
        return node
    _node = reverseNode(node.next)  # 返回最后的节点_node
    node.next.next, node.next = node, None
    return _node
    
```



## 单链表判断是否有环

```python
# 快慢指针
def searchLoop(root):
    if not root:
        return False
    slow = root
    quick = root
    while quick and quick.next:
        slow = slow.next
        quick = quick.next.next
        if quick == slow:
            return True
    return False
```

思路：快慢指针，慢指针与快指针相遇，则有环



## 单链表寻找环入口

```python
# 三指针：一快指针，两慢指针
def searchLoopDoor(root):
    if not root:
        return False
    slow = root
    quick = root
    slow_2 = root  # 用于寻找入口
    while quick and quick.next:
        slow = slow.next
        quick = quick.next.next
        if quick == slow:
            while slow != slow_2:
                slow = slow.next
                slow_2 = slow_2.next
            return slow_2  # 环开始的位置
    return False
```

思路：快慢指针相碰后，第二个慢指针开始遍历，当两个慢指针相遇，则相遇点即为环入口



## 单链表找交点

```python
# 快速法
def searchIntersectionNode(headA, headB):
    nodeA = headA
    nodeB = headB
    while nodeA != nodeB:
        if not nodeA.next:
            nodeA.next = headB
        else:
            nodeA = nodeA.next

        if not nodeB.next:
            nodeB.next = headA
        else:
            nodeB = nodeB.next
    return nodeA  # return nodeB
```

思路一（快速法）：两个指针 nodeA，nodeB 分别从 headA，headB开始遍历，当 nodeA 遍历到尾部的时候，指向 headB，当 nodeB 遍历到尾部的时候，转向 headA。当两个指针再次相遇的时候，如果两个链表有交点，则指向交点，如果没有则指向 NULL（类似两车相遇问题）。

思路二（常规法）：先算得两个链表长度（两次遍历取得），取得长度差，长的链表先走长度差步，然后两链表同时再走，相遇的点即为交点。

## 队列、链表、栈

### ArrayList

扩容规则：当数据长度将超过ArrayList的长度时，ArrayList会创建一个新的ArrayList，大小为原来的1.5倍，并将原ArrayList的数据复制到新的ArrayList。



### LinkList

~~扩容规则：链表直接新增节点，不存在空间不够~~



### Vector（线程安全）

扩容规则：每次增大到原来的2倍



### set

不可有重复且无序（内部排序，而不是根据插入顺序排序）

扩容规则：装载因子0.75，超过75%，自动扩容到原来的2倍



### HashMap

扩容规则：扩大到原来的两倍



### HashTable（线程安全）

扩容规则：扩大到原来的两倍+1



## 队列、链表、栈的关系与区别

队列：顺序存储结构，在一端（队尾）插入，一端（队头）删除的线性表（FIFO）

<img src="C:\Users\pc\Desktop\知识累积\队列插入.png" alt="队列插入" style="zoom:50%;" />

<img src="C:\Users\pc\Desktop\知识累积\队列删除.png" alt="队列删除" style="zoom:50%;" />

链表：链式存储结构，尾端插入，首端删除，即上述的链表（**链表有迭代器可使用**）

```Java
// 迭代器遍历集合的速度非常快，优先使用迭代器遍历
class IteratorTest{
    public static void doInterator(List<String> _list){
        Iterator<String> iterator = _list.iterator();
        while(iterator.hasNext()){
            String str = iterator.next();
        }
    }
    
    public static void main(String[] args){
        LinkedList<String> _list = new LinkedList<String>();
        this.doIterator(_list)
    }
}
```

栈：只在队列尾部插入、删除的线性表（FILO）

### 顺序表和链式表

​	区别：

​		一个存储空间连续，一个存储空间不连续

​		顺序表空间利用率高，链表不仅容易产生碎片，也要携带指针，所以略低

​		**插入、删除、访问、移动少的情况适合顺序表**；**插入、删除、移动多，而访问少，适合链表**

解决不同类型的问题，顺序表和链表对应的时间复杂度也不同。

根据顺序表和链表在存储结构上的差异，问题类型主要分为以下 2 类：

1. 问题中主要涉及访问元素的操作，元素的插入、删除和移动操作极少；
2. 问题中主要涉及元素的插入、删除和移动，访问元素的需求很少；


第 1 类问题适合使用顺序表。这是因为，顺序表中存储的元素可以使用**数组下标**直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为 `O(1)`；而在链表中访问数据元素，需要从表头依次遍历，直到找到指定节点，花费的时间复杂度为 `O(n)`;

第 2 类问题则适合使用链表。链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动元素，因此链表中插入、删除或移动数据所耗费的时间复杂度为 `O(1)`；而顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，因此时间复杂度至少为 `O(n)`;

![顺序表和链表的存储结构对比](http://data.biancheng.net/uploads/allimg/181125/2-1Q12512244c10.gif)

# 五、哈希表

哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。



## 哈希函数

哈希函数也叫散列函数，它对不同的输出值得到一个固定长度的消息摘要。理想的哈希函数对于不同的输入应该产生不同的结构，同时散列结果应当具有同一性（输出值尽量均匀）和雪崩效应（微小的输入值变化使得输出值发生巨大的变化）。



## 哈希冲突

现实中的哈希函数不是完美的，当两个不同的输入值对应一个输出值时，就会产生“碰撞”，这个时候便需要解决冲突。

常见的冲突解决方法有开放定址法，链地址法，建立公共溢出区等。实际的哈希表实现中，使用最多的是链地址法

#### 开放定址法

当发生冲突时，再次寻找（可能向后寻找，可以能先前后寻找），直到找到空位置为止



#### 链地址法

链地址法的基本思想是，为每个 Hash 值建立一个单链表，当发生冲突时，将记录插入到链表中。

例 2 设有 8 个元素 { a,b,c,d,e,f,g,h } ，采用某种哈希函数得到的地址分别为： {0 ， 2 ， 4 ， 1 ， 0 ， 8 ， 7 ， 2} ，当哈希表长度为 10 时，采用链地址法解决冲突的哈希表如下图所示：

![哈希表](C:\Users\pc\Desktop\知识累积\哈希表.jpg)



（**简单来说，哈希表通过键（一个数据的关键码）计算出一个hash值（也称地址），将hash值（地址）存储在hash表中，通过计算hash值可直接查询到这个数据的值，加快了查询速度**）



## HashMap的扩容方式

采用装载因子的方式，如默认装载因子是0.75，代表当HashMap的容量已经被使用75%时，自动扩大容量到原来的两别。



## Hash源码

**HashMap对象的key、value值均可为null。**

**Hashtable对象的key、value值均不可为null。**

**且两者的的key值均不能重复，若添加key相同的键值对，后面的value会自动覆盖前面的value，但不会报错。**

```java
// HashMap
public V put(K key, V value){
    return putVal(hash(key), key, value, false, true);
}

static final int hash(Object key){
    int h;
    return (key == null) ? 0 : (h = key.hashCode))^(h >>> 16);
}
// HashMap在put的时候会调用hash()方法来计算key的hashcode值，可以从hash算法中看出当key==null时返回的值为0。因此key为null时，hash算法返回值为0，不会调用key的hashcode方法。
```

```java
// HashTable
public synchronized V put(K key, V value){
    // Make sure the value is not null
    if (value == null){
        throw new NullPointerException();
    }
    Entry<?,?> tab[] = table;
    int hash = key.hashCode();
    int index = (hash & 0x7FFFFFFF) % tab.length;
    @SuppressWarnings("unchecked")
    Entry<K,V> entry = (Entry<K,V>tab[index]);
    for(;entry != null ; entry = entry.next){
        if ((entry.hash == hash) && entry.key.equals(key)){
            V old = entry.value;
            entry.value = value;
            return old;
        }
    }
    
    addEntry(hash, key, value, index);
    return null;
}
// 上面可以看出当Hashtable存入的value为null时，抛出NullPointerException异常。如果value不为null，而key为空，在执行到int hash = key.hashCode()时同样会抛出NullPointerException异常
```







# 六、二叉树

```python
# 二叉树定义
class TreeNode(object):
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```



## 前中后遍历（递归）

```python
# 前序
def preNode(node, _list):
    if not node:
        return
    _list.append(node.val)
    preNode(node.left)
    preNode(node.right)
    
# 中序
def inOrder(node):
    if not node:
        return
    preNode(node.left)
    _list.append(node.val)
    preNode(node.right)

# 后序
def postOrder(node):
    if not node:
        return
    preNode(node.left)
    preNode(node.right)
    _list.append(node.val)
```



## 层序遍历

### DFS（深度优先）

```python
# 深度优先
def dfs(node, level, _list):
    '''_list是二维数组'''
    if not node:
        return
    if level > len(_list):
        _list.append([])
    _list[level-1].append(node.val)
    dfs(node.left, level+1, _list)
    dfs(node.right, level+1, _list)


if __name__ == '__main__':
    _list = []
    root = TreeNode(8)
    root.left = TreeNode(7)
    root.right = TreeNode(6)
    root.right.right = TreeNode(5)
    dfs(root,1,_list)
    res = [j for i in _list for j in i]
    print(res)
```



### BFS（广度优先）

```python
def bfs(node):
    _stack = []
    _list = []
    if not node:
        return
    _stack.append(node)  # 入队
    while len(_stack) > 0:
        size = len(_stack)
        for i in range(size):
            p = _stack.pop(0)  # 取出队尾的节点
            _list.append(p.val)
            if p.left:
                _stack.append(p.left)
            if p.right:
                _stack.append(p.right)
    return _list

```

思路：队列存储节点（FIFO)



## 二叉树性值及衍生

### 二叉树

- 性质1：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1）
- 性质2：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1）
- 性质3：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：`n0 = n2 + 1`

tip：只有前序遍历和后续遍历，无法确定二叉树，必须有中序遍历的结果



### 满二叉树

深度为k且有2^k －1个结点的二叉树称为满二叉树



### 完全二叉树

深度为 k 的，有n个结点的二叉树，当且仅当其每个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应，称之为完全二叉树。（除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点）

- 性质4：具有 n 个结点的完全二叉树的深度为 log2n + 1（等比数列）

若以数组层次存储二叉树(0开始)，则：

​	索引为n的节点：

​		左孩：2 n+1

​		右孩：2 n+2

​		父节点：[(n-1)/2]



### 二叉排序树

- 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；

- 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；

- 左、右子树也分别为二叉排序树；

- 没有键值相等的节点
- 或为空树



### 平衡二叉树

是对二叉排序树的改进

- 它的左子树和右子树都是平衡二叉树，

- 左子树和右子树的深度之差的绝对值不超过1
- 或为空树



### 哈夫曼树

- 定义：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。

​	树的带权路径长度：∑（叶子节点权值*叶子节点等级<!--(0开始)-->）

​	节点的带权路径长度权值：结点到树根之间的路径长度与该结点上权的乘积



### B-树

**B-树**：B-树是一种非二叉的查找树， 除了要满足查找树（排序树）的特性，还要满足以下结构特性：

一棵 m 阶的B-树：

1. 树的根或者是一片叶子(一个节点的树),或者其儿子数在 2 和 m 之间。
2. 除根外，所有的非叶子结点的孩子数在 m/2 和 m 之间。
3. 所有的叶子结点都在相同的深度。

B-树的平均深度为logm/2(N)。执行查找的平均时间为O(logm)；



### B+树

MySql 索引使用B+树或hash表

B+树：所有的数据均存放在叶子节点，冗余的非叶子节点，维护查找<img src="C:\Users\pc\Desktop\知识累积\B+树.png" alt="B+树" style="zoom:55%;" />



### B+树与B-树的区别

### B-树和B+树的区别

**1.B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。**

如下所示B-树/B+树查询节点 key 为 50 的 data。

B-树：

<img src="https://upload-images.jianshu.io/upload_images/1446087-d62ec6e83eebe06f?imageMogr2/auto-orient/strip|imageView2/2/w/739/format/webp" alt="img" style="zoom:50%;" />

B+树：<img src="https://upload-images.jianshu.io/upload_images/1446087-d690fabe8c919281?imageMogr2/auto-orient/strip|imageView2/2/w/738/format/webp" alt="img" style="zoom:50%;" />



### 红黑树

自平衡的二叉查找树，每次插入删除后都通过特定操作保持平衡

TreeMap是基于红黑树实现的，HashMap当链表长度大于8时，剩下的数据也会存入红黑树

<img src="C:\Users\pc\Desktop\知识累积\红黑树.png" alt="红黑树" style="zoom:50%;" />



### 堆

如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为最大堆。

同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为最小堆。

**最大堆的根结点中的元素在整个堆中是最大的；**

**最小堆的根结点中的元素在整个堆中是最小的。**



### Trie 树

Trie 树，又称前缀树，字典树， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。

Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。

Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。





# 七、计算机网络

TCP/IP协议架构：从上到下依次为：应用层、传输层、网络层、网络接口层

![TCP&IP](C:\Users\pc\Desktop\知识累积\TCP&IP.jpg)

## HTTP协议

- HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80
- HTTP 是**无连接无状态**的

### 请求报文

- 状态行

- 请求头

- 消息主体

- ```xml
  <method> <request-URL> <version>
  <headers>
  
  <entity-body>
  ```

Header中可能由哪些字段：

cookie，请求时传递给服务端的cookie信息 set-cookie，响应报文首部设置要传递给客户端的cookie信息 allow，

支持什么HTTP方法 last-modified，

资源的最后修改时间 expires,设置资源缓存的失败日期 content-language，

**实体的资源语言 content-encoding，（返回）**

**实体的编码格式 content-length，（返回）**

实体主体部分的大小单位是字节 content-range，

**返回的实体的哪些范围 content-type（返回）**，

哪些类型 accept-ranges，

处理的范围请求 age，

告诉客户端服务器在多久前创建了响应 vary，

代理服务器的缓存信息 location，

用于指定重定向后的URI If-Match，	

**值是资源的唯一标识 User-Agent，**

将创建请求的浏览器和用户代理名称等信息传递给服务器 Transfer-Encoding，

传输报文的主体编码方式 connection，

管理持久连接，keep-alive , close Cache-Control，控制浏览器的强缓存

**处理请求的网站，Server（返回）**

**发送请求的地址，refer（请求）**

**请求方法，method**



### 响应报文

- 状态行
- 响应头(Response Header)
- 响应正文

```xml
HTTP/1.1 200 OK

Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

<html>...
```

常见的状态码有如下几种：

- `200 OK` 客户端请求成功
- `301 Moved Permanently` 请求永久重定向
- `302 Moved Temporarily` 请求临时重定向
- `304 Not Modified` 文件未修改，可以直接使用缓存的文件。
- `400 Bad Request` 由于客户端请求有语法错误，不能被服务器所理解。
- `401 Unauthorized` 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用
- `403 Forbidden` 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因
- `404 Not Found` 请求的资源不存在，例如，输入了错误的URL
- `500 Internal Server Error` 服务器发生不可预期的错误，导致无法完成客户端的请求。
- `503 Service Unavailable` 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。
- `203 Non-Authoritative Information` 非授权信息.请求成功.但返回的meta信息不在原始服务器而是一个副本

1×× : 请求处理中，请求已被接受，正在处理

2×× : 请求成功，请求被成功处理 200 OK

3×× : 重定向，要完成请求必须进行进一步处理 301 : 永久性转移 302 ：暂时性转移 304 ：已缓存

4×× : 客户端错误，请求不合法 400：Bad Request,请求有语法问题 403：拒绝请求 404：客户端所访问的页面不存在

5×× : 服务器端错误，服务器不能处理合法请求 500 ：服务器内部错误 503 ：服务不可用，等等



### 条件GET

HTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案。详见 [RFC2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) 。

1. HTTP 条件 GET 使用的时机？

   客户端之前已经访问过某网站，并打算再次访问该网站。

2. HTTP 条件 GET 使用的方法？

   客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。

   下面是一个具体的发送接受报文示例：

   客户端发送请求：

   ```
    GET / HTTP/1.1  
    Host: www.sina.com.cn:80  
    If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT  
    Connection: Close  
   ```

   第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 `If-Modified-Since` 字段判断响应文件没有更新，如果没有更新，服务器返回一个 `304 Not Modified`响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。

   ```
    HTTP/1.0 304 Not Modified  
    Date: Thu, 04 Feb 2010 12:38:41 GMT  
    Content-Type: text/html  
    Expires: Thu, 04 Feb 2010 12:39:41 GMT  
    Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT  
    Age: 28  
    X-Cache: HIT from sy32-21.sina.com.cn  
    Connection: close 
   ```

   如果服务器端资源已经更新的话，就返回正常的响应。

### 请求方式

HTTP 定义了与服务器交互的不同方法，最基本的方法有4种，分别是`GET`，`POST`，`PUT`，`DELETE`。`URL`全称是资源描述符，我们可以这样认为：一个`URL`地址，它用于描述一个网络上的资源，而 HTTP 中的`GET`，`POST`，`PUT`，`DELETE`就对应着对这个资源的查，增，改，删4个操作。

1. GET 用于信息获取，而且应该是安全的 和 幂等的。

   所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。

   幂等的意味着对同一 URL 的多个请求应该返回同样的结果。

   GET 请求报文示例：

   ```
    GET /books/?sex=man&name=Professional HTTP/1.1
    Host: www.example.com
    User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
    Gecko/20050225 Firefox/1.0.1
    Connection: Keep-Alive
   ```

2. POST 表示可能修改变服务器上的资源的请求。

   ```
    POST / HTTP/1.1
    Host: www.example.com
    User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
    Gecko/20050225 Firefox/1.0.1
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 40
    Connection: Keep-Alive
   
    sex=man&name=Professional  
   ```

3. 注意:

   - GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制
   - 理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制
   - 参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里

### 持久连接（keep alive）

我们知道 HTTP 协议采用“请求-应答”模式，当**使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP 协议为无连接的协议）**；当**使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。**

在 HTTP 1.0 版本中，并没有官方的标准来规定 Keep-Alive 如何工作，因此实际上它是被附加到 HTTP 1.0协议上，如果客户端浏览器支持 Keep-Alive ，那么就在HTTP请求头中添加一个字段 Connection: Keep-Alive，当服务器收到附带有 Connection: Keep-Alive 的请求时，它也会在响应头中添加一个同样的字段来使用 Keep-Alive 。这样一来，客户端和服务器之间的HTTP连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。

在 **HTTP 1.1 版本中，默认情况下所有连接都被保持**，如果**加入 "Connection: close" 才关闭**。目前大部分浏览器都使用 HTTP 1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep-Alive 连接就看服务器设置情况。

由于 HTTP 1.0 没有官方的 Keep-Alive 规范，并且也已经基本被淘汰，以下讨论均是针对 HTTP 1.1 标准中的 Keep-Alive 展开的。

注意：

- HTTP Keep-Alive 简单说就是保持当前的TCP连接，避免了重新建立连接。
- HTTP 长连接不可能一直保持，例如 `Keep-Alive: timeout=5, max=100`，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。
- HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。另外，Keep-Alive也不能保证客户端和服务器之间的连接一定是活跃的，在 HTTP1.1 版本中也如此。唯一能保证的就是当连接被关闭时你能得到一个通知，所以不应该让程序依赖于 Keep-Alive 的保持连接特性，否则会有意想不到的后果。
  - 使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1. 判断传输数据是否达到了Content-Length 指示的大小；2. 动态生成的文件没有 Content-Length ，它是分块传输（chunked），这时候就要根据 chunked 编码来判断，chunked 编码的数据在最后有一个空 chunked 块，表明本次传输数据结束，详见[这里](http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html)。什么是 chunked 分块传输呢？下面我们就来介绍一下。



### Transfer-Encoding

Transfer-Encoding 是一个用来标示 HTTP 报文传输格式的头部值。尽管这个取值理论上可以有很多，但是当前的 HTTP 规范里实际上只定义了一种传输取值——chunked。

如果一个HTTP消息（请求消息或应答消息）的Transfer-Encoding消息头的值为chunked，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。

每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个CRLF （回车及换行），然后是数据本身，最后块CRLF结束。在一些实现中，块大小和CRLF之间填充有白空格（0x20）。

最后一块是单行，由块大小（0），一些可选的填充白空格，以及CRLF。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。消息最后以CRLF结尾。

一个示例响应如下：

```
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

25
This is the data in the first chunk

1A
and this is the second one
0
```

**注意：**

- chunked 和 multipart 两个名词在意义上有类似的地方，不过在 HTTP 协议当中这两个概念则不是一个类别的。multipart 是一种 Content-Type，标示 HTTP 报文内容的类型，而 chunked 是一种传输格式，标示报头将以何种方式进行传输。
- chunked 传输不能事先知道内容的长度，只能靠最后的空 chunk 块来判断，因此对于下载请求来说，是没有办法实现进度的。在浏览器和下载工具中，偶尔我们也会看到有些文件是看不到下载进度的，即采用 chunked 方式进行下载。
- chunked 的优势在于，服务器端可以边生成内容边发送，无需事先生成全部的内容。HTTP/2 不支持 Transfer-Encoding: chunked，因为 HTTP/2 有自己的 streaming 传输方式（Source：[MDN - Transfer-Encoding](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding)）。



### HTTP Pipelining（HTTP 管线化）

默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。在使用持久连接的情况下，某个连接上消息的传递类似于`请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3`。

HTTP Pipelining（管线化）是将多个 HTTP 请求整批提交的技术，在传送过程中不需等待服务端的回应。使用 HTTP Pipelining 技术之后，某个连接上的消息变成了类似这样`请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3`。

注意下面几点：

- 管线化机制通过**持久连接**（persistent connection）（**keep-alive**）完成，**仅 HTTP/1.1 支持此技术**（HTTP/1.0不支持）
- 只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制
- 初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持 HTTP/1.1 版本的协议
- 管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变
- HTTP /1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可
- 由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持

更多关于 HTTP Pipelining 的知识可以参考[这里](https://developer.mozilla.org/en-US/docs/Web/HTTP/Pipelining_FAQ)。

### 会话跟踪

1. 什么是会话？

   客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。

2. 什么是会话跟踪？

   会话跟踪指的是对**同一个用户对服务器的连续的请求和接受响应的监视**。

3. 为什么需要会话跟踪？

   浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要**判断是否是同一个用户**，所以才有会话跟踪技术来实现这种要求。

1. 会话跟踪常用的方法:

   1. URL 重写

      URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。

   2. 隐藏表单域

      将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示

   3. Cookie

      Cookie 是Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,在客户端可以进行保存,以便下次使用。

      客户端可以采用两种方式来保存这个 Cookie 对象，一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。

      Cookie 是可以被客户端禁用的。

   4. Session:

      每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。

      在服务器端会创建一个 session 对象，产生一个 sessionID 来标识这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。

      Session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。



## HTTP over SSL/TLS (HTTPS)

HTTPS 即 HTTP over TLS，是一种在加密信道进行 HTTP 内容传输的协议。

两点：

​	加密传输

​	身份认证

> TLS 的早期版本叫做 SSL。SSL 的 1.0, 2.0, 3.0 版本均已经被废弃，出于安全问题考虑广大浏览器也不再对老旧的 SSL 版本进行支持了，因此这里我们就统一使用 TLS 名称了。

TLS 的基本过程如下（取自 [what-happens-when-zh_CN](https://github.com/skyline75489/what-happens-when-zh_CN#tls)）：

- 客户端发送一个 `ClientHello` 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。
- 服务器端向客户端返回一个 `ServerHello` 消息，消息中包含了服务器端的 **TLS 版本**，**服务器所选择的加密和压缩算法**，以及**数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书**，证书中包含了**公钥**。**客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥**。证书中还包含了该证书所应用的域名范围（Common Name，简称 CN），用于客户端验证身份。
- **客户端根据自己的信任 CA 列表，验证服务器端的证书是否可信**。如果认为可信（具体的验证过程在下一节讲解），客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于**生成新的对称密钥**
- 服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数**生成自己的对称主密钥**
- 客户端发送一个 `Finished` 消息给服务器端，使用对称密钥加密这次通讯的一个散列值
- 服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 `Finished` 消息，也使用协商好的对称密钥加密
- 从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容

从上面的过程可以看到，TLS 的完整过程需要三个算法（协议），**密钥交互算法**，**对称加密算法**，**和消息认证算法**（TLS 的传输会使用 MAC(message authentication code) 进行完整性检查）。

我们以 Github 网站使用的 TLS 为例，使用浏览器可以看到它使用的加密为 `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`。其中密钥交互算法是 `ECDHE_RSA`，对称加密算法是 `AES_128_GCM`，消息认证（MAC）算法为 `SHA256`。

### TLS证书机制

HTTPS 过程中很重要的一个步骤，是服务器需要有 CA 颁发的证书，客户端根据自己的信任 CA 列表验证服务器的身份。现代浏览器中，证书验证的过程依赖于证书信任链。

所谓证书信任链，即一个证书要依靠上一级证书来证明自己是可信的，最顶层的证书被称为根证书，拥有根证书的机构被称为根 CA。

还是以 Github 为例，在浏览器中我们可以看到它的证书信任链如下：

```
DigiCert High Assurance EV Root CA` -> `DigiCert SHA2 Extended Validation Server CA` -> `Github.com
```

从上到下即 Root CA -> 二级 CA -> 网站。

前面提到，证书当中包括 CN(Common Name)，浏览器在验证证书的同时，也会验证 CN 的正确性。即不光需要验证“这是一个合法的证书”，还需要验证“这是一个用于 Github.com 的证书”。

既然所有的信任，最终要落到根 CA 上，根证书本身又是怎么获得的呢？答案也很简单，根证书一般是操作系统自带的。不管是桌面系统 Windows，macOS 还是移动端系统 Android, iOS 都会内置一系列根证书。随着操作系统本身的升级，根证书也会随着升级进行更新。

对浏览器而已，浏览器当然也有选择信任某个根证书的权利。Chrome 浏览器一般是跟随系统根证书信任的。Firefox 浏览器通常是使用自带的一套证书信任机制，不受系统证书的影响。

在使用 `curl` 等工具时，我们还可以自行选择证书进行信任。

> 有权威的信任，最终都要落到一个单点信任，不管是 Root CA，还是微软，苹果，谷歌等操作系统厂商。



## 网络攻击

### 跨站CSRF攻击

CSRF（Cross-site request forgery，跨站请求伪造）

CSRF(XSRF) 顾名思义，是伪造请求，冒充用户在站内的正常操作。

例如，一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问：

```
  http://example.com/bbs/create_post.php?title=标题&content=内容
```

那么，我们只需要在论坛中发一帖，包含一链接：

```
  http://example.com/bbs/create_post.php?title=我是脑残&content=哈哈
```

只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。（**相当于构造了个URL请求，让用户通过自己的信息发送请求**）

**如何防范 CSRF 攻击**？可以注意以下几点：

- 关键操作只接受 POST 请求

- 验证码

  CSRF 攻击的过程，往往是在**用户不知情的情况下构造网络请求**。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。

  但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。

- 检测 Referer

  常见的互联网页面与页面之间是存在联系的，比如你在 `www.baidu.com` 应该是找不到通往`www.google.com` 的链接的，再比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的 `Referer` 中

  通过检查 `Referer` 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 `Referer` 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击。

- Token

  目前主流的做法是使用 Token 抵御 CSRF 攻击。下面通过分析 CSRF 攻击来理解为什么 Token 能够有效

  CSRF 攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击。

  另一个更通用的做法是保持原有参数不变，另外添加一个参数 Token，其值是随机的。这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击。

  Token 使用原则

  - Token 要足够随机————只有这样才算不可预测
  - Token 是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度
  - Token 要注意保密性————**敏感操作使用 post，防止 Token 出现在 URL 中**

  **注意**：过滤用户输入的内容**不能**阻挡 csrf，我们需要做的是过滤请求的**来源**。



### XSS（Cross Site Scripting，跨站脚本攻击）

XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。

运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧——一个关不掉的窗口：

```
  while (true) {
      alert("你关不掉我~");
  }
```

也可以是盗号或者其他未授权的操作。

XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。

**如何防御 XSS 攻击？**

理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于 script。防御 XSS 攻击最简单直接的方法，就是过滤用户的输入。

如果不需要用户输入 HTML，可以直接对用户的输入进行 HTML escape 。下面一小段脚本：

```
  <script>window.location.href=”http://www.baidu.com”;</script>
```

经过 escape 之后就成了：

```
  &lt;script&gt;window.location.href=&quot;http://www.baidu.com&quot;&lt;/script&gt;
```

它现在会像普通文本一样显示出来，变得无毒无害，不能执行了。

当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。更好的方法可能是，将用户的输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从**白名单**中拿取。



### MITM（中间人攻击）

HTTPS 的过程并不是密不透风的，HTTPS 有若干漏洞，给中间人攻击（Man In The Middle Attack，简称 MITM）提供了可能。

所谓中间人攻击，指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。



### SSL剥离

SSL 剥离即阻止用户使用 HTTPS 访问网站。由于并不是所有网站都只支持 HTTPS，大部分网站会同时支持 HTTP 和 HTTPS 两种协议。用户在访问网站时，也可能会在地址栏中输入 `http://` 的地址，第一次的访问完全是明文的，这就给了攻击者可乘之机。通过攻击 DNS 响应，攻击者可以将自己变成中间人。

> DNS 作为基于 UDP 的协议是相当不安全的，为了保证 DNS 的安全可以使用 DNS over TCP 等机制，这里不赘述了。



### HSTS预防技术

为了防止上面说的这种情况，一种叫做 HSTS 的技术被引入了。HSTS（HTTP Strict Transport Security）是用于**强制浏览器使用 HTTPS** 访问网站的一种机制。它的基本机制是在服务器返回的响应中，加上一个特殊的头部，指示浏览器对于此网站，强制使用 HTTPS 进行访问：

```plaintext
Strict-Transport-Security: max-age=31536000; includeSubdomains; preload
```

可以看到如果这个过期时间非常长，就是导致在很长一段时间内，浏览器都会强制使用 HTTPS 访问该网站。

HSTS 有一个很明显的缺点，是需要等待第一个服务器的影响中的头部才能生效，但如果第一次访问该网站就被攻击呢？为了解决这个问题，浏览器中会带上一些网站的域名，被称为 HSTS preload list。对于在这个 list 的网站来说，直接强制使用 HTTPS。



### 伪造证书攻击

HSTS 只解决了 SSL 剥离的问题，然而即使在全程使用 HTTPS 的情况下，我们仍然有可能被监听。

假设我们想访问 `www.google.com`，但我们的 DNS 服务器被攻击了，指向的 IP 地址并非 Google 的服务器，而是攻击者的 IP。当攻击者的服务器也有合法的证书的时候，我们的浏览器就会认为对方是 Google 服务器，从而信任对方。这样，攻击者便可以监听我们和谷歌之前的所有通信了。

可以看到攻击者有两步需要操作，第一步是需要攻击 DNS 服务器。第二步是攻击者自己的证书需要被用户信任，这一步对于用户来说是很难控制的，需要证书颁发机构能够控制自己不滥发证书。

> 2015 年 Google 称发现赛门铁克旗下的 Thawte 未经同意签发了众多域名的数千个证书，其中包括 Google 旗下的域名和不存在的域名。当年 12 月，Google 发布公告称 Chrome、Android 及其他 Google 产品将不再信任赛门铁克旗下的"Class 3 Public Primary CA"根证书。
>
> 2016 年 Mozilla 发现沃通 CA 存在严重的信任问题，例如偷签 `github.com` 的证书，故意倒填证书日期绕过浏览器对 SHA-1 证书的限制等，将停止信任 WoSign 和 StartCom 签发的新证书。



### HPKP预防技术

HPKP 技术是为了解决伪造证书攻击而诞生的。

HPKP（Public Key Pinning Extension for HTTP）在 HSTS 上更进一步，HPKP 直接在返回头中存储服务器的公钥指纹信息，一旦发现指纹和实际接受到的公钥有差异，浏览器就可以认为正在被攻击：

```plaintext
Public-Key-Pins: pin-sha256="base64=="; max-age=expireTime [; includeSubDomains][; report-uri="reportURI"]
```

和 HSTS 类似，HPKP 也依赖于服务器的头部返回，不能解决第一次访问的问题，浏览器本身也会内置一些 HPKP 列表。

> HPKP 技术仍然不能阻止第一次访问的攻击问题，部署和配置 HPKP 相当繁琐，一旦网站配置错误，就会导致网站证书验证失败，且在过期时间内无法有效恢复。HPKP 的机制也引来了一些安全性问题。Chrome 67 中废除了对 HPKP 的支持，在 Chrome 72 中 HPKP 被彻底移除。



## TCP协议

- TCP 提供一种**面向连接的、可靠的**字节流服务
- 在一个 TCP 连接中，仅有**两方**进行彼此通信。**广播和多播不能用于 TCP**
- TCP 使用校验和，**确认和重传机制来保证可靠传输**
- TCP 给**数据分节进行排序**，并**使用累积确认保证数据的顺序不变和非重复**
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行**拥塞控制**

**注意**：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。



### TCP的核心

#### 拥塞控制算法

- **慢启动**：维护一个拥塞窗口（可等于发送窗口），在开始发送数据时，先发送1个数据段，在每次收到确认后，可发送的数据段的个数cwnd+1，以此来逐步增打发送窗口。
- **拥塞避免（加法增大AI）**：当慢启动算法的cwnd达到一个设定的上限ssthresh时，停止慢启动算法，开始使用拥塞避免算法，每经过一个RTT就使cwnd+1，（**拥塞是把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞**），当网络出现拥塞时（拥塞导致超时等），将ssthresh/2，并重置cwnd=1，重新启动慢开始算法。
- **快速重传**：与之前的数据丢失时，接收方什么都不做不同，现在接收方需要在每次接收到无序数据包时，都回发确认最后收到的有序数据包序号，当重复三次相同确认后（避免了接收方误认为是网络拥堵引起的超时），接受方进行快速重传丢失的数据包。
- **快速恢复（乘法减小MD）**：当丢失了部分数据包时，将ssthresh = cwnd/2，同时cwnd = ssthresh，开始执行拥塞避免算法。
- **补**：加法增大AI和乘法减小MD，合称**AIMD算法**

### TCP如何保证包的顺序传输

两点：

​	**①停止等待协议**

​	**②ARQ超时重传**

发送主机每次发送数据时，TCP就给每个数据包**分配一个序列号**并且在一个特定的时间内等待接收主机对分配的这个**序列号**进行确认，

如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。

接收主机**利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。**

#### 核心算法

- 为了保证数据包的可靠传递，**发送方必须把已发送的数据包保留在缓冲区（方便重传）**
- 同时为每个已发送的数据包启动一个超时定时器（重传定时器RTO）
- 如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区
- 否则，**重传该数据包，直到收到应答或重传次数超过规定的最大次数为止**。
- 接收方收到数据包后，先进行**CRC校验**，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可放在数据包中捎带过去。



### 三次握手与四次挥手

所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。

三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 `connect()` 时。将触发三次握手。

- 第一次握手(SYN=1, seq=x):

  客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。

  发送完毕后，客户端进入 `SYN_SEND` 状态。

- 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):

  服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 `SYN_RCVD` 状态。

- 第三次握手(ACK=1，ACKnum=y+1)

  客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1

  发送完毕后，客户端进入 `ESTABLISHED` 状态，当服务器端接收到这个包时，也进入 `ESTABLISHED` 状态，TCP 握手结束。

三次握手的过程的示意图如下：

<img src="C:\Users\pc\Desktop\知识累积\三次握手.png" style="zoom:50%;" />

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 `close()` 操作即可产生挥手操作。

- 第一次挥手(FIN=1，seq=x)

  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

  发送完毕后，客户端进入 `FIN_WAIT_1` 状态。

- 第二次挥手(ACK=1，ACKnum=x+1)

  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

  发送完毕后，服务器端进入 `CLOSE_WAIT` 状态，客户端接收到这个确认包之后，进入 `FIN_WAIT_2` 状态，等待服务器端关闭连接。

- 第三次挥手(FIN=1，seq=y)

  服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。

  发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后一个ACK。

- 第四次挥手(ACK=1，ACKnum=y+1)

  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。

  服务器端接收到这个确认包之后，关闭连接，进入 `CLOSED` 状态。

  客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 `CLOSED` 状态。

四次挥手的示意图如下：

<img src="C:\Users\pc\Desktop\知识累积\四次挥手.png" style="zoom:50%;" />

### SYN攻击

- 什么是 SYN 攻击（SYN Flood）？

  在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.

  SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。

  SYN 攻击是一种典型的 DoS/DDoS 攻击。

- 如何检测 SYN 攻击？

  检测 SYN 攻击非常的方便，当你在服务器上看到**大量的半连接状态**时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

- 如何防御 SYN 攻击？

  SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：

  - 缩短超时（SYN Timeout）时间
  - 增加最大半连接数
  - 过滤网关防护
  - SYN cookies技术

TCP 的连接，实际上是一种**纯软件层面**的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。

**TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接**。

[TCP-Keepalive-HOWTO](http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/) 有对 TCP KeepAlive 特性的详细介绍，有兴趣的同学可以参考。这里主要说一下，TCP KeepAlive 的局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。



## UDP协议

UDP 是一个简单的传输层协议。和 TCP 相比，UDP 有下面几个显著特性：

- UDP 缺乏可靠性。UDP 本身**不提供确认，序列号，超时重传**等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次
- UDP **数据报是有长度**的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。
- UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。**UDP 发送数据报之前也不需要经过握手创建连接**的过程。
- UDP **支持多播和广播**。



## IP协议

由四段，每段一个字节，8位，最大值255

分为两部分：

网络地址：网络地址表示其属于互联网的哪一个网络

主机地址：主机地址表示其属于该网络中的哪一台主机。

A、B、C、D、E三类地址

![快问快答，计算机网络面试夺命20问_服务端_06](https://s2.51cto.com/images/blog/202108/02/0ef421fb820ff26e645a073f8781a92c.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184)

A: 0.0.0.0 - 126.0.0.0

B: 128.0.0.0 - 191.255.0.0

C: 192.0.0.0 - 223.255.255.0

D: 多播地址：址的网络号取值于224-239

E: 保留地址：址的网络号取值于240 - 255



## Socket（套接字）

socket可用于程序间通信（进程间通信）

Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。

Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –> 读写(write/read) –> 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。

[socked 笔记链接](https://hit-alibaba.github.io/interview/basic/network/Socket-Programming-Basic.html)

以下代码展现了一个简单的客户端与服务端通信的过程：

```java
// 客户端
import java.io.*;
import java.net.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class Client{
    public static void main(String args[]){
        new WindowClient();
    }
}

class WindowClient extends JFrame implements Runnable, ActionListener{
    JButton connection,send;
    JTextField inputText;
    JTextArea showResult;
    Socket socket = null;
    DataInputStream in = null;
    DataOutputStream out = null;
    Thread thread;
    WindowClient(){
        socket = new Socket();
        connection = new JButton("连接服务器");
        send = new JButton("发送");
        send.setEnabled(false);
        inputText = new JTextField(6);
        showResult = new JTextArea();
        add(connection,BorderLayout.NORTH);
        JPanel pSouth = new JPanel();
        pSouth.add(new JLabel("输入："));
        pSouth.add(inputText);
        pSouth.add(send);
        add(new JScrollPane(showResult),BorderLayout.CENTER);
        add(pSouth,BorderLayout.SOUTH);
        connection.addActionListener(this);
        send.addActionListener(this);
        thread = new Thread();
        setBounds(10,30,460,400);
        setVisible(true);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }

    public void actionPerformed(ActionEvent e){
        if(e.getSource() == connection){
            // 连接
            try {
                if (socket.isConnected()) {
                } else {
                    InetAddress inetAddress = InetAddress.getByName("10.130.146.83");
                    InetSocketAddress inetSocketAddress = new InetSocketAddress(inetAddress, 4331);
                    socket.connect(inetSocketAddress);
                    in = new DataInputStream(socket.getInputStream());
                    out = new DataOutputStream(socket.getOutputStream());
                    send.setEnabled(true);
                    if (!(thread.isAlive())) {
                        thread = new Thread(this);
                    }
                    thread.start();
                }
            }
            catch (IOException eee){
                System.out.println(eee);
                socket = new Socket();
            }
        }
        if(e.getSource() == send) {
            String s = inputText.getText();
            try {
                out.writeUTF(s);
            } catch (IOException ee) {
                System.out.println(ee);
            }
        }
    }
    public void run(){
        String s = null;
        double result = 0;
        while(true){
            try{
                s = in.readUTF();
                showResult.append(s);
            }
            catch (IOException e){
                showResult.setText("与服务器断开连接");
                socket = new Socket();
                break;
            }
        }
    }
}
```



```java
// 服务端
import java.io.*;
import java.net.*;
import java.util.*;

public class Server{
    public static void main(String args[]){
        ServerSocket server = null;
        ServerThread thread;
        Socket you = null;
        while(true){
            try{server = new ServerSocket(4331);}
            catch(IOException e){
                System.out.println("正在监听");
            }
            try{
                System.out.println("等待客户呼叫");
                you = server.accept();
                System.out.println("客户的地址：" + you.getInetAddress());
            }
            catch (IOException ee){
                System.out.println("正在等待客户");
            }
            if(you != null){
                new ServerThread(you).start();
            }
        }
    }
}

class ServerThread extends Thread{
    Socket socket;
    DataOutputStream out = null;
    DataInputStream in = null;
    String s = null;
    ServerThread(Socket t){
        socket = t;
        try{
            out = new DataOutputStream(socket.getOutputStream());
            in = new DataInputStream(socket.getInputStream());
        }
        catch(IOException e){}
    }

    
    public void run(){
        while(true){
            try{
                String r = in.readUTF();
                System.out.println(r);
                Scanner scanner = new Scanner(System.in);
                String s = scanner.nextLine();
                out.writeUTF(s);
            }
            catch(IOException e){
                System.out.println("客户离开");
                return;
            }
        }
    }
}
```



## 面试题

夺命20问: https://blog.51cto.com/u_15320685/3251870



# 八、操作系统

管理计算机硬件和软件资源的程序(管理内存，磁盘，cpu)

将应用程序与硬件隔离, 用户和计算机资源的媒介, 为应用程序提供一个运行环境, 使得用户可以运行程序，管理文件，使用系统



## 体系结构基础

①数据和指令都是二进制表示

②顺序执行：计算机运行时，将要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，再自动的按顺序从内存中取出一条一条指令地执行

③计算机硬件由运算器、控制器、存储器、输入和输出设备五部分组成

### 二进制表示

#### 机器数

二进制、0表示正，1表示负

用正负号表示的数称为“真值”，真值转换为二进制字串的过程称为编码

#### 源码

二进制、第一位表示符号位，其余位表示值

#### 反码

二进制、正数的反码是本身，负数的反码是：符号位不变，其余为鼠取反

#### 补码

二进制，正数的补码是本身，负数的补码是：符号位不变，其余位数取反，最后+1（反码+1）

#### 定点数和浮点数

定点数：定点数是小数点固定的数。在计算机中没有专门表示小数点的位，小数点的位置是约定默认的。一般固定在机器数的最低位之后，或是固定在符号位之后。前者称为**定点纯整数**，后者称为**定点纯小数**。

​	缺点：数值表示的范围太小，运算时容易产生溢出



浮点数：浮点数是小数点的位置可以变动的数。为增大数值表示范围，防止溢出，采用浮点数表示法。浮点表示法类似于十进制中的科学计数法。

在计算机中通常把浮点数分成**阶码**和**尾数**两部分来表示，其中**阶码一般用补码定点整数**表示，**尾数一般用补码或原码定点小数**表示。为保证不损失有效数字，对尾数进行规格化处理，也就是平时所说的科学记数法，即保证尾数的最高位为1，实际数值通过阶码进行调整

阶符表示指数的符号位、阶码表示幂次、数符表示尾数的符号位、尾数表示规格化后的小数值。

```
N = 尾数×基数阶码（指数）
```



### 位、字节、字

#### 位（bit）

八位0/1

#### 字节（Byte)

8个bit构成一个byte，一个字母占一个字节，一个汉字占两个字节

#### 字（word）

若干字节构成字，例如八位机，一个字是一个字节（8bit），16位机，一个字2字节（16bit)

字是计算机进行数据处理和运算的单位。



### 字节序

字节顺序是指占内存多于一个字节类型的数据在内存中的存放顺序，通常有小端、大端两种字节顺序。

#### 小端

小端字节序指低字节数据存放在内存低地址处，高字节数据存放在内存高地址处

​	X86平台

#### 大端

大端字节序（网络字节序）是高字节数据存放在低地址处，低字节数据存放在高地址处

​	网络协议

例子：

```
Big Endian
低地址                                            高地址
---------------------------------------------------->
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     12     |      34    |     56      |     78    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Little Endian
低地址                                            高地址
---------------------------------------------------->
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     78     |      56    |     34      |     12    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```



## 操作系统基础

操作系统的五大功能，分别为：作业管理、文件管理、存储管理、输入输出设备管理、进程及处理机管理

### 中断

所谓的中断就是在计算机执行程序的过程中，由于出现了某些特殊事情，使得CPU暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。中断一般分为三类：

1. 由计算机硬件异常或故障引起的中断，称为**内部异常中断**；
2. 由程序中执行了引起中断的指令而造成的中断，称为**软中断**（这也是和我们将要说明的系统调用相关的中断）；
3. 由外部设备请求引起的中断，称为**外部中断**。简单来说，对中断的理解就是对一些特殊事情的处理。

### 中断处理程序

当中断发生的时候，系统需要去对中断进行处理，对这些中断的处理是由操作系统内核中的特定函数进行的，这些处理中断的特定的函数就是我们所说的中断处理程序了。

### 中断优先级

```
机器错误 > 时钟 > 磁盘 > 网络设备 >  终端 > 软件中断
```

### 系统调用

进程的两个级别：用户级和核心级（用户态和核心态）

**程序的执行一般是在用户态下执行的**，但当程序**需要使用操作系统提供的服务**时，比如说打开某一设备、创建文件、读写文件等，就需要**向操作系统发出调用服务的请求，这就是系统调用**。

Linux系统有专门的函数库来提供这些请求操作系统服务的入口，这个函数库中包含了操作系统所提供的对外服务的接口。**当进程发出系统调用之后**，它所处的运行状态就会由**用户态变成核心态**。但这个时候，进程本身其实并没有做什么事情，这个时候是由**内核在做相应的操作**，去完成进程所提出的这些请求。

系统调用和中断的关系就在于，**当进程发出系统调用申请的时候，会产生一个软件中断**。产生这个软件中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了。

那么用户态和核心态之间的区别是什么呢？（以下区别摘至《UNIX操作系统设计》）

1. **用户态的进程能存取它们自己的指令和数据**，**但不能存取内核指令和数据**（或其他进程的指令和数据）。然而，**核心态下的进程能够存取内核和用户地址**
2. 某些**机器指令是特权指令**，在**用户态下执行特权指令会引起错误**

对此要理解的一个是，在系统中内核并不是作为一个与用户进程平行的估计的进程的集合，**内核是为用户进程运行**的。



## 并发技术

```
多道程序-> 分时系统-> 多任务系统
```

多任务系统：程序在系统上以进程方式运行，**每个进程具有独立的地址空间、相互隔离**。CPU 由操作系统统一进行分配。每个进程都有机会得到 CPU，同时在操作系统控制之下，如果一个进程运行超过了一定时间，就会被暂停掉，失去 CPU 资源。这样就避免了一个程序的错误导致整个系统死机。如果操作系统分配给各个进程的运行时间都很短，CPU 可以在多个进程间快速切换，就像很多进程都同时在运行的样子。几乎所有现代操作系统都是采用这样的方式支持多任务，例如 Unix，Linux，Windows 以及 macOS。

### 进程

**进程是一个具有独立功能的程序关于某个数据集合的一次运行活动**。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。

进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。**文本区域存储处理器执行的代码**；**数据区域存储变量和进程执行期间使用的动态分配的内存**；**堆栈区域存储着活动过程调用的指令和本地变量。**第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。

（说白了就是，运行起来的程序，具有文本区（代码）、数据区域（内存）、堆栈（变量和指令））

#### 进程状态

1. 等待态：等待某个事件的完成；
2. 就绪态：等待系统分配处理器以便运行；
3. 运行态：占有处理器正在运行。

![进程](C:\Users\pc\Desktop\知识累积\进程.png)

运行态→等待态 往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。

等待态→就绪态 则是等待的条件已满足，只需分配到处理器后就能运行。

运行态→就绪态 不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。

就绪态→运行态 系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态

#### 进程调度

高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：

- 高级调度：(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；
- 中级调度：(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。
- 低级调度：(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；



**非抢占式调度和抢占式调度**

- 非抢占式

  分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程。

- 抢占式

  操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式。



#### 调度策略

​	响应时间: 从用户输入到产生反应的时间

​	周转时间: 从任务开始到任务结束的时间

​	CPU任务可以分为交互式任务和批处理任务，调度最终的目标是合理的使用CPU，使得交互式任务的响应时间尽可能短，用户不至于感到延迟，同时使得批处理任务的周转时间尽可能短，减少用户等待的时间。



#### 调度算法

##### FIFO

先到先服务

调度的顺序就是任务到达就绪队列的顺序。

公平、简单(FIFO队列)、非抢占、不适合交互式。未考虑任务特性，平均等待时间可以缩短

##### SJF

最短的作业(CPU区间长度最小)最先调度。

可以证明，SJF可以保证最小的平均等待时间。

- Shortest Remaining Job First (SRJF)

  SJF的可抢占版本，比SJF更有优势。

SJF(SRJF): 如何知道下一CPU区间大小？根据历史进行预测: 指数平均法。

##### HRRN

最高响应比优先

![26-响应比公式](C:\Users\pc\Desktop\知识累积\26-响应比公式.png)

##### RR

设置一个时间片，按时间片来轮转调度（“轮叫”算法）

优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；

如何确定时间片？

时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS。

##### 优先权调度

每个任务关联一个优先权，调度优先权最高的任务。

注意：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。

FCFS是RR的特例，SJF是优先权调度的特例。这些调度算法都不适合于交互式系统。

##### 多级队列调度

- 按照一定的规则建立多个进程队列
- 不同的队列有固定的优先级（高优先级有抢占权）
- 不同的队列可以给不同的时间片和采用不同的调度方法

存在问题1：没法区分I/O bound和CPU bound；

存在问题2：也存在一定程度的“饥饿”现象；

##### 多级反馈队列

在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。

可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。

最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等。



#### 死锁

死锁: 多个进程因循环等待资源而造成无法执行的现象。

死锁会造成进程无法执行，同时会造成系统资源的极大浪费(资源无法释放)。

死锁产生的4个必要条件：

- 互斥使用(Mutual exclusion)

  指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。

- 不可抢占(No preemption)

  指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

- 请求和保持(Hold and wait)

  指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

- 循环等待(Circular wait) 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

死锁避免——银行家算法

思想: 判断此次请求是否造成死锁若会造成死锁，则拒绝该请求

（**说白了，死锁的产生和打破都离不开四个条件：互斥、循环等待、不可抢占、请求和保持**）



#### 进程间的通信

- 消息传递（管道、FIFO、消息队列）
- 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）
- 共享内存（匿名的和具名的）
- 远程过程调用（Solaris门和Sun RPC）
- 套接字Socket通信



### 线程

多进程解决了前面提到的多任务问题。然而很多时候不同的程序需要共享同样的资源（文件，信号量等），如果全都使用进程的话会导致切换的成本很高，造成 CPU 资源的浪费。于是就出现了线程的概念。

线程，有时被称为轻量级进程(Lightweight Process，LWP），**是程序执行流的最小单元**。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。

线程具有以下属性：

1. 轻型实体线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。**线程的实体包括程序、数据和TCB**。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。

2. 独立调度和分派的基本单位。

   在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。

3. 可并发执行。 在一个进程中的多个线程之间，可以**并发执行**，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。

4. 共享进程资源。 在**同一进程中的各个线程，都可以共享该进程所拥有的资源**，这首先表现在：所有**线程都具有相同的地址空间（进程的地址空间）**，这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开文件、定时器、信号量等。由于同一个进程内的线程共享内存和文件，所以**线程之间互相通信不必调用内核**。 线程共享的环境包括：**进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯**)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。



### 锁

这里讨论的主要是多线程编程中需要使用的锁，网上有关于锁的文章实在是非常多而且乱套，让新手不知道从何下手。这里我们不去钻名词和概念的牛角尖，而是直接从本质上试图解释一下锁这个很常用的多线程编程工具。

锁要解决的是线程之间争取资源的问题，这个问题大概有下面几个角度：

- **资源是否是独占（独占锁 - 共享锁）**
- **抢占不到资源怎么办（互斥锁 - 自旋锁）**
- **自己能不能重复抢（重入锁 - 不可重入锁）**
- **竞争读的情况比较多，读可不可以不加锁（读写锁）**

上面这几个角度不是互相独立的，在实际场景中往往要它们结合起来，才能构造出一个合适的锁。

##### 独占锁 - 共享锁

当一个共享资源只有一份的时候，通常我们使用独占锁，常见的即各个语言当中的 Mutex。当共享资源有多份时，可以使用前面提到的 Semaphere。

##### 互斥锁 - 自旋锁

对于互斥锁来说，如果一个线程已经锁定了一个互斥锁，第二个线程又试图去获得这个互斥锁，则第二个线程将被挂起（即休眠，不占用 CPU 资源）。

在计算机系统中，频繁的挂起和切换线程，也是有成本的。自旋锁就是解决这个问题的。

自旋锁，指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

容易看出，当资源等待的时间较长，用互斥锁让线程休眠，会消耗更少的资源。当资源等待的时间较短时，使用自旋锁将减少线程的切换，获得更高的性能。

较新版本的 Java 中的 `synchornized` 和 .NET 中的 `lock`（`Monitor`） 的实现，是结合了两种锁的特点。简单说，它们在发现资源被抢占之后，会先试着自旋等待一段时间，如果等待时间太长，则会进入挂起状态。通过这样的实现，可以较大程度上挖掘出锁的性能。

##### 重入锁 - 不可重入锁

可重入锁（ReetrantLock），也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。换一种说法：同一个线程再次进入同步代码时，可以使用自己已获取到的锁。

使用可重入锁时，在同一线程中多次获取锁，不会导致死锁。使用不可重入锁，则会导致死锁发生。

Java 中的 `synchornized` 和 .NET 中的 `lock`（`Monitor`） 都是可重入的。

##### 读写锁

有些情况下，对于共享资源读竞争的情况远远多于写竞争，这种情况下，对读操作每次都进行加速，是得不偿失的。读写锁就是为了解决这个问题。

读写锁允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞。简单可以总结为，读读不互斥，读写互斥，写写互斥。

对读写锁来说，有一个升级和降级的概念，即当前获得了读锁，想把当前的锁变成写锁，称为升级，反之称为降级。锁的升降级本身也是为了提升性能，通过改变当前锁的性质，避免重复获取锁。

（**说白了，锁是为了解决线程之间资源的相互竞争**）



### 协程

协程，又称微线程，纤程。英文名 Coroutine。

协程可以理解为**用户级线程**，协程和线程的区别是：**线程是抢占式的调度，而协程是协同式的调度**，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。



### IO多路复用

IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：

1. 当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。
2. 当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。
3. 如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。
4. 如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。
5. 如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。

与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。





## 内存管理

### 页面置换算法

#### FIFO

先进先出置换算法

- 先入先出，即淘汰最早调入的页面。

#### OPT（MIN）

最佳页面置换算法

- 选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。

  可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。

#### LRU

最近最久未使用的置换算法

- 用过去的历史预测将来，选最近最长时间没有使用的页淘汰(也称最近最少使用)。

  LRU准确实现：计数器法，页码栈法。

  由于代价较高，通常不使用准确实现，而是采用近似实现，例如Clock算法。

#### Clock

时钟页面置换算法

该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。

当发生缺页中断时，算法首先检查表针指向的页面：

- 如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；
- 如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；

<img src="https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt="时钟页面置换算法" style="zoom:50%;" />



#### LFU

最不常用置换算法

实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面



## 磁盘与文件





# 九、数据库

模式、表、视图、索引

## 索引

## 锁

## 事务处理

### 事务的特性

- A, atomacity **原子性** 事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。

- C, consistency **一致性**

  事务将数据库从一种一致状态转变为下一种一致状态。也就是说，事务在完成时，必须使所有的数据都保持一致状态（各种 constraint 不被破坏）。

- I, isolation **隔离性** 由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。换句话说，一个事务的影响在该事务提交前对其他事务都不可见。

- D, durability **持久性**

  事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。

### 事务的隔离级别

1. 未提交读(Read Uncommitted)

   直译就是"读未提交"，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变。

   Read Uncommitted允许脏读。

2. 已提交读(Read Committed)

   直译就是"读提交"，意思就是语句提交以后，即执行了 Commit 以后别的事务就能读到这个改变，只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别。

   Read Commited 不允许脏读，但会出现非重复读。

​	3. 可重复读(Repeatable Read)：

​	直译就是"可以重复读"，这是说在同一个事务里面先后执行同一个查询语句的时候，得到的结果是一样的。

​	Repeatable Read 不允许脏读，不允许非重复读，但是会出现幻象读。

​	4. 串行读(Serializable)

​	直译就是"序列化"，意思是说这个事务执行的时候不允许别的事务并发执行。完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

​	Serializable 不允许不一致现象的出现。

### 事务会出现的问题

1. 脏读(Dirty Read)

   当一个事务读取另一个事务尚未提交的修改时，产生脏读。

   同一事务内不是脏读。 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚，也就是说读取出的数据其实是错误的。

2. 非重复读(Nonrepeatable Read) 一个事务对同一行数据重复读取两次，但是却得到了不同的结果。同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生非重复读。

3. 幻像读(Phantom Reads) 事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。

   当对某行执行插入或删除操作，而该行属于某个事务正在读取的行的范围时，会发生幻像读问题。

4. 丢失修改(Lost Update)

   第一类：当两个事务更新相同的数据源，如果第一个事务被提交，第二个却被撤销，那么连同第一个事务做的更新也被撤销。

   第二类：有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。

​	**（上述问题，可通过四个事务隔离级别解决）**

## Sql语句

### 基本命令：

#### 常用的查询条件

| 查询条件             | 谓词                                            |
| -------------------- | ----------------------------------------------- |
| 比较                 | =, >, <, >+, <=, !=, <>, !>, !<; NOT+上述比较符 |
| 确认范围             | BETWEEN AND, NOT BETWEEN AND                    |
| 确定集合             | IN, NOT IN                                      |
| 字符匹配             | LIKE, NOT LIKE                                  |
| 空值                 | IS NULL, IS NOT NULL                            |
| 多重条件（逻辑运算） | AND, OR, NOT                                    |

#### 聚集函数

**只能用于SELECT子句和GROUP BY中的HAVING子句**,**不能用于WHERE的条件表达式**

| 函数                         | 作用                 |
| ---------------------------- | -------------------- |
| COUNT(*)                     | 统计元组个数         |
| COUNT([DISTINCT\|ALL]<列名>) | 统计一列中值的个数   |
| SUM([DISTINCT\|ALL]<列名>)   | 计算一列中值的总和   |
| AVG([DISTINCT\|ALL]<列名>)   | 计算一列中值的平均值 |
| MAX([DISTINCT\|ALL]<列名>)   | 求一列值的最大值     |
| MIN([DISTINCT\|ALL]<列名>)   | 求一列值的最小值     |

#### 其他

| 写法                      | 作用                         |
| ------------------------- | ---------------------------- |
| GROUP BY 列名 HAVING 条件 | 聚类                         |
| ORDER BY 列名 DESC\|ASC   | 排序                         |
| EXISTS, NOT EXISTS        | 存在,不存在(返回true或false) |

### 创建语句

```sql
-- 新建模式(数据库)
CREATE SCHEMA IF NOT EXISTS student_class_system;

-- 新建学生表格
USE student_class_system;
CREATE TABLE if NOT EXISTS student(
id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
Sno INT NULL COMMENT"学号",
Sname VARCHAR(255) NULL COMMENT"姓名",
Ssex INT Null COMMENT"性别：0：男，1：女",
Sage INT NULL COMMENT"年龄",
Sdept VARCHAR(255) NULL COMMENT"所在系") 
ENGINE=INNODB DEFAULT CHARSET = utf8 COLLATE utf8_bin;

-- 新建课程表
USE student_class_system;
CREATE TABLE IF NOT EXISTS course(
id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
Cno INT NULL COMMENT"课程号",
Cname VARCHAR(255) NULL COMMENT"课程名",
Cpno INT NULL COMMENT"先行课",
Ccredit INT NULL COMMENT"学分")
ENGINE=INNODB DEFAULT CHARSET = utf8 COLLATE utf8_bin;

-- 新建成绩表
USE student_class_system;
CREATE TABLE IF NOT EXISTS sc(
id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
Sno INT NULL COMMENT"学号",
Cno INT NULL COMMENT"课程号",
Grade INT NULL COMMENT"成绩"")
ENGINE=INNODB DEFAULT CHARSET = utf8 COLLATE utf8_bin;

-- 新建视图(行列子集视图)
USE student_class_system;
CREATE VIEW boy_student
AS
SELECT Sno, Sname, Sage
FROM student
where Ssex = "0"


-- 新建索引
CREATE UNIQUE INDEX stusno ON student(Sno ASC);
```



### 复制表语句

```mysql
-- 不会有主键
create table table_name_new as (select * from table_name_old);

-- 只复制表结构
create table table_name_new as select * from table_name_old where 1=2;
-- 或者
create table table_name_new like table_name_old;


-- 只复制表的数据
-- 表结构一样时
insert into table_name_new select * from table_name_old;
-- 表结构不一样时
insert into table_name_new(column1,column2...) select column1,column2... from table_name_old;
```



### 修改语句

```sql
-- 修改基本表
ALTER TABLE student
ADD Sphone VARCHAR(32) NULL COMMENT"电话号码";
ALTER TABLE student
ADD Sqq INT NULL COMMENT"qq号";

-- 修改基本表列数据类型
ALTER TABLE student MODIFY Sqq VARCHAR(32);

-- 增添条件约束：取唯一值(索引)
ALTER TABLE student ADD UNIQUE(Sno);

-- 删除列
ALTER TABLE student DROP COLUMN Sqq;

-- 还有很多，自行探索
-- 补充
-- 3.添加INDEX(普通索引)
ALTER TABLE table_name ADD INDEX index_name ( column )
-- 4.添加FULLTEXT(全文索引)
ALTER TABLE table_name ADD FULLTEXT ( column)
-- 5.添加多列索引
ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3 )
```

### 查询语句

```sql
-- 单表查询
SELECT DISTINCT Sno  -- DISTINCT关键字为剔除重复,不写默认为ALL
FROM student
WHERE Ssex = 0

-- 连表查询: 自连接
SELECT Cno, Cpno
FROM course c_1, course c_2  -- 省略 AS
WHERE c_1.Cno= c_2.Cpno

-- 连表查询: 外连接: 左连接(列出左表的所有元组)
SELECT student.Sno, Sname, Ssex, Sage, Sdept,Cno,Grade
From student LEFT OUTER JOIN sc ON(student.Sno = sc.Sno);

-- 连表查询: 外连接: 右连接(列出右表的所有元组)
SELECT student.Sno, Sname, Ssex, Sage, Sdept,Cno,Grade
From student RIGHT OUTER JOIN sc ON(student.Sno = sc.Sno);

-- 连表查询: 多表连接(两个以上的表连接)
SELECT student.Sno, Sname, Cname, Grade
FROM student, sc, course
WHERE student.Sno = sc.Sno AND sc.Cno = course.Cno;

-- 嵌套查询: 不相关子查询(子查询条件不依赖父查询)
SELECT Sno, Sname, Sdept
FROM student
WHERE Sdept IN(
	SELECT Sdept
	FROM student
	WHERE Sname = "崔博奥");  -- 不相关子查询由内而外查询

-- 嵌套查询: 相关子查询(子查询条件依赖父查询)
SELECT Sno,Cno
FROM sc sc_1
WHERE Grade >= (
	SELECT AVG(Grade)
	FROM sc sc_2
	WHERE sc_1.Sno = sc_2.Sno);

-- 嵌套查询: EXISTS(查询到有记录，返回true，否则返回false)
SELECT Sname
FROM student
WHERE EXISTS(
	SELECT *
	FROM sc
	WHERE Sno = student.Sno AND Cno = 1);  -- 相关子查询

-- 嵌套查询: NOT EXISTS(查询到有记录，返回false，否则返回true)
SELECT Sname
FROM student
WHERE NOT EXISTS(
	SELECT *
	FROM course
	WHERE NOT EXISTS(
    	SELECT *
        FROM sc
    	WHERE Sno=student.Sno AND Cno=course.Cno));  -- 相关子查询

-- 集合查询: UNION/ UNION ALL(并)
SELECT Sno
FROM sc
WHERE Cno = 1
UNION
SELECT SNO
FROM sc
WHERE Cno = 2;

-- 集合查询: INTERSECT(交)
SELECT *
FROM student
WHERE Sdept='信息管理学院'
INTERSECT
SELECT
FROM student
WHERE Sage <= 21

-- 集合查询: EXCEPT(差)
SELECT *
FROM student
WHERE Sdept = "信息管理学院"
EXCEPT
SELECT *
FROM student
WHERE Sage <= 21

-- 派生表查询(FROM子句构造派生表)
SELECT Sno,Cno
FROM sc, (SELECT Sno, AVG(Grade) 
          FROM sc 
          GROUP BY Sno) AS Avg_sc(avg_sno, avg_grade)
WHERE sc.Sno = Avg_sc.avg_sno AND sc.Grade >= Avg_sc.avg_grade;

-- 分页查询(LIMIT)
SELECT * FROM student LIMIT 3,3;  -- 第一个参数为起始行（0开始），第二个参数为返回的行数

-- 分段查询: 子查询方式实现
SELECT *
FROM
	(SELECT COUNT(*) A FROM sc WHERE Grade >= 90) a,
	(SELECT COUNT(*) B FROM sc WHERE Grade >= 75 AND Ccredit < 90) b,
	(SELECT COUNT(*) C FROM sc WHERE Grade >= 60 AND Ccredit < 75) c,
	(SELECT COUNT(*) D FROM sc WHERE Grade < 60) d

-- 分段查询: 集合查询方式实现
SELECT COUNT(*) A FROM sc WHERE Grade >= 90
UNION ALL  -- union all 合并但保留重复元组
SELECT COUNT(*) A FROM sc WHERE Grade >= 75 AND Ccredit < 90
UNION ALL
SELECT COUNT(*) A FROM sc WHERE Grade >= 60 AND Ccredit < 75
UNION ALL
SELECT COUNT(*) A FROM sc WHERE Grade < 60

```



### 插入语句

```sql
-- 元组形式插入
INSERT INTO student(Sno,Sname,Ssex,Sage,Sdept,Sphone,Sqq)
VALUES(2019214258,"崔博奥",0, 21, "信息管理学院", "19871207037","1538217591");


-- 查询结果插入
INSERT INTO student(Sno,Sname,Ssex,Sage,Sdept,Sphone,Sqq)
	SELECT Sno+1,Sname,Ssex,Sage,Sdept,Sphone,Sqq
	FROM student
	where id = 1;
```



### 更新语句

```sql
-- 元组形式修改
UPDATE student
set Sname = "小崔"
WHERE id = 2;


-- 修改多个元组数据
UPDATE student
SET Sdept = "信息管理与信息系统";


-- 子查询形式修改
UPDATE student
set Sdept = "信息管理学院"
WHERE Sno in(
	SELECT Sno
	FROM sc
	WHERE Ccredit = 100);
```



### 删除语句

```sql
-- 删除一个元组
DELETE
FROM student
WHERE id = 5;

-- 删除多个元组(本例为删除全部)
DELETE
FROM student;


-- 子查询方式删除
DELETE
FROM student
WHERE Sno IN(
	SELECT Sno
	FROM sc
	WHERE Ccredit = 100);
```

## 数据库面试题

https://blog.51cto.com/u_12302929/4827251?articleABtest=0





# 十、设计模式

**至少看懂**！！！！！

## 设计模式六大原则

- 单一职责原则：即一个类应该只负责一项职责（**多用组合、聚集，少用继承**）
- 里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象（**子类可替换基类**）
- 依赖倒转原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；**抽象不应该依赖细节，细节应该依赖抽象**
- 接口隔离原则：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上（**多个隔离的接口升过一个大接口**）
- 迪米特法则：一个对象应该对其他对象保持最少的了解（**少与其他实体发生交互**）
- 开闭原则：**对扩展开放，对修改关闭**

## 设计模式类型

### 创建型

### 行为型

### 结构型

## 设计模型举例

### [单例模式](https://www.runoob.com/design-pattern/singleton-pattern.html)

主要思想：涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

过程：

```java
// 创建单例模式类，隐藏构造方法
public class SingleObject {
 
   //创建 SingleObject 的一个对象
   private static SingleObject instance = new SingleObject();
 
   //让构造函数为 private，这样该类就不会被实例化
   private SingleObject(){}
 
   //获取唯一可用的对象
   public static SingleObject getInstance(){
      return instance;
   }
 
   public void showMessage(){
      System.out.println("Hello World!");
   }
}
```

```java
// 调用试试
public class Test{
    public static void main(String[] args){
        SingleObject singleObject = SingleObject.getInstance();
        singleObject.showMessage();
    }
}
```



### [策略模式](https://www.runoob.com/design-pattern/strategy-pattern.html)

主要思想：将每个算法分别封装起来，让它们可以互相替换，让客户端在运行时可以调用不同的算法（类似接口的回调）

过程：

```java
// 创建策略接口
public interface Strategy{
    // 接口中的方法
    public int doOperation(int num1, int num2);
}
```

```java
// 不同的方式实现接口
public class Operation_1{
    @Override
    public int doOperation(int num1, int num2){
        // 第一种算法或过程，例如如下加法
        int res = num1 + num2
        return res;
    }
}

// 不同的方式实现接口
public class Operation_2{
    @Override
    public int doOperation(int num1, int num2){
        // 第二种算法或过程，例如如下减法
        int res = num1 - num2
        return res;
    }
}

// 不同的方式实现接口
public class Operation_3{
    @Override
    public int doOperation(int num1, int num2){
        // 第三种算法或过程，例如如下乘法
        int res = num1 * num2
        return res;
    }
}
```

```java
// 创建策略工厂（隐藏不同实现接口的类的构造方法）
public class StrategyFactory {
	 public static Strategy getStrategy(String type) {
		if (type == null || type.isEmpty()) {
			throw new IllegalArgumentException("type should not be empty.");
		}
		if (type.equals("1")) {
			return new Operation_1();
		} else if (type.equals("2")) {
			return new Operation_2();
		} else if (type.equals("3")) {
            return new Operation_3();
        }
		
		return null;
	 }
}


```

```java
// 客户端调用试试
public class Test{
    public static void main(String[] args){
        // 方法一：不适用策略工厂，直接接口回调
        Strategry strategry = new Operation_1();
        print(strategry.doOperation(1,2));
        
        // 方法二：使用策略工厂
        print(StrategryFactory.getStrategry("1").doOperation(1,2))
    }
}
```



### [访问者模式](https://www.runoob.com/design-pattern/visitor-pattern.html)



### [装饰器模式](https://www.runoob.com/design-pattern/decorator-pattern.html)



### [适配器模式](https://www.runoob.com/design-pattern/adapter-pattern.html)



### [工厂方法模式](https://www.runoob.com/design-pattern/factory-pattern.html)



### [责任链模式](https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html)



# 十一、C++和C的一些基础语法

## 虚函数和纯虚函数

**永远不要在构造和析构中直接/间接调用virtual函数**

​	定义一个函数为虚函数，不代表函数为不被实现的函数。

​	定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。

​	定义一个函数为纯虚函数，才代表函数没有被实现。

​	定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数

（**说白了，虚函数就是java中的抽象方法或者用来重载的空方法，纯虚函数就是类必须实现的接口的抽象方法或者就是一个抽象类的抽象方法**）



## 指针

## 构造和析构函数





# 十二、Java的一些基础知识

## [并发编程](https://juejin.cn/post/6844903940987994125)

三要素：

​	原子性：指的是一个或多个操作要么全部执行成功要么全部执行失败。

​	顺序性：程序的执行顺序和代码的执行顺序一至（处理器可能会对指令进行重排序）

​	可见性：一个线程对共享变量的修改，其他线程是立马可见的

## Math类

| 1      | [xxxValue()](https://www.runoob.com/java/number-xxxvalue.html) 将 Number 对象转换为xxx数据类型的值并返回。 |
| ------ | ------------------------------------------------------------ |
| **2**  | [compareTo()](https://www.runoob.com/java/number-compareto.html) 将number对象与参数比较。 |
| **3**  | [equals()](https://www.runoob.com/java/number-equals.html) 判断number对象是否与参数相等。 |
| **4**  | [valueOf()](https://www.runoob.com/java/number-valueof.html) 返回一个 Number 对象指定的内置数据类型 |
| **5**  | [toString()](https://www.runoob.com/java/number-tostring.html) 以字符串形式返回值。 |
| **6**  | [parseInt()](https://www.runoob.com/java/number-parseInt.html) 将字符串解析为int类型。 |
| **7**  | [abs()](https://www.runoob.com/java/number-abs.html) 返回参数的绝对值。 |
| **8**  | [ceil()](https://www.runoob.com/java/number-ceil.html) 返回大于等于( >= )给定参数的的最小整数，类型为双精度浮点型。 |
| **9**  | [floor()](https://www.runoob.com/java/number-floor.html) 返回小于等于（<=）给定参数的最大整数 。 |
| 10     | [rint()](https://www.runoob.com/java/number-rint.html) 返回与参数最接近的整数。返回类型为double。 |
| **11** | [round()](https://www.runoob.com/java/number-round.html) 它表示**四舍五入**，算法为 **Math.floor(x+0.5)**，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 |
| **12** | [min()](https://www.runoob.com/java/number-min.html) 返回两个参数中的最小值。 |
| **13** | [max()](https://www.runoob.com/java/number-max.html) 返回两个参数中的最大值。 |
| 14     | [exp()](https://www.runoob.com/java/number-exp.html) 返回自然数底数e的参数次方。 |
| **15** | [log()](https://www.runoob.com/java/number-log.html) 返回参数的自然数底数的对数值。**运用换底公式，可实现logN（N为任意数）,logN(x) = log(x)/log(N)** |
| **16** | [pow()](https://www.runoob.com/java/number-pow.html) 返回第一个参数的第二个参数次方。 |
| **17** | [sqrt()](https://www.runoob.com/java/number-sqrt.html) 求参数的算术平方根。 |
| 18     | [sin()](https://www.runoob.com/java/number-sin.html) 求指定double类型参数的正弦值。 |
| 19     | [cos()](https://www.runoob.com/java/number-cos.html) 求指定double类型参数的余弦值。 |
| 20     | [tan()](https://www.runoob.com/java/number-tan.html) 求指定double类型参数的正切值。 |
| 21     | [asin()](https://www.runoob.com/java/number-asin.html) 求指定double类型参数的反正弦值。 |
| 22     | [acos()](https://www.runoob.com/java/number-acos.html) 求指定double类型参数的反余弦值。 |
| 23     | [atan()](https://www.runoob.com/java/number-atan.html) 求指定double类型参数的反正切值。 |
| 24     | [atan2()](https://www.runoob.com/java/number-atan2.html) 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。 |
| 25     | [toDegrees()](https://www.runoob.com/java/number-todegrees.html) 将参数转化为角度。 |
| 26     | [toRadians()](https://www.runoob.com/java/number-toradians.html) 将角度转换为弧度。 |
| 27     | [random()](https://www.runoob.com/java/number-random.html) 返回一个随机数。 |

# 十三、C#的一些基础语法





# 十四、Python的一些基础语法

## 常用函数

```python
# 默认数组:defaultdict()，当查询的key不存在时会自动补上一个value
dict1 = defaultdict(int)
```

```python
# 自动形成元组zip()
# zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。
# 如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。
a = [1,2,3]
b = [4,5,6]
c = [4,5,6,7,8]
zipped = zip(a,b)
>>> [(1, 4), (2, 5), (3, 6)]
# 解压
zip(*zipped)
>>> [(1, 2, 3), (4, 5, 6)]
```

```python
# 排序函数:sorted()
sorted(iterable, cmp=None, key=None, reverse=False)
>>> students = [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]
>>> sorted(students, key=lambda s: s[2])            # 按年龄排序
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
```

```python
# 二分查找函数库:bisect
import bisect
# 查找i
pos = bisect.bisect(_list,i)

# 查找+插入i
bisect.insort(_list,i)	
```

```python
# enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。
seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
list(enumerate(seasons, start=1))       # 下标从 1 开始
>>> [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```

```python
# 进制转化
# 1、各种进制转10进制,int("X进制的数",X)
int("一个其他进制的字符串，如10、11、110",2)
# 2、10进制转其他进制,hex(十进制数)、bin(十进制数)
hex(F1)
bin(3)
```



数学函数

| 函数                                                         | 返回值 ( 描述 )                                              |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [abs(x)](https://www.runoob.com/python/func-number-abs.html) | **返回数字的绝对值，如abs(-10) 返回 10**                     |
| [ceil(x)](https://www.runoob.com/python/func-number-ceil.html) | **返回数字的上入整数，如math.ceil(4.1) 返回 5**              |
| [cmp(x, y)](https://www.runoob.com/python/func-number-cmp.html) | 如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1    |
| [exp(x)](https://www.runoob.com/python/func-number-exp.html) | 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045         |
| [fabs(x)](https://www.runoob.com/python/func-number-fabs.html) | 返回数字的绝对值，如math.fabs(-10) 返回10.0                  |
| [floor(x)](https://www.runoob.com/python/func-number-floor.html) | 返回数字的下舍整数，如math.floor(4.9)返回 4                  |
| [log(x)](https://www.runoob.com/python/func-number-log.html) | **如math.log(math.e)返回1.0,math.log(100,10)返回2.0是，以自然数e为底的** |
| [log10(x)](https://www.runoob.com/python/func-number-log10.html) | **返回以10为基数的x的对数，如math.log10(100)返回 2.0**       |
| [max(x1, x2,...)](https://www.runoob.com/python/func-number-max.html) | **返回给定参数的最大值，参数可以为序列。**                   |
| [min(x1, x2,...)](https://www.runoob.com/python/func-number-min.html) | **返回给定参数的最小值，参数可以为序列。**                   |
| [modf(x)](https://www.runoob.com/python/func-number-modf.html) | 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 |
| [pow(x, y)](https://www.runoob.com/python/func-number-pow.html) | **x**y 运算后的值。**                                        |
| [round(x ,n)](https://www.runoob.com/python/func-number-round.html) | **返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。** |
| [sqrt(x)](https://www.runoob.com/python/func-number-sqrt.html) | **返回数字x的平方根**                                        |

## 随机函数：

| 函数                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [choice(seq)](https://www.runoob.com/python/func-number-choice.html) | 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 |
| [randrange ([start,\] stop [,step])](https://www.runoob.com/python/func-number-randrange.html) | 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1 |
| [random()](https://www.runoob.com/python/func-number-random.html) | 随机生成下一个实数，它在[0,1)范围内。                        |
| [seed([x\])](https://www.runoob.com/python/func-number-seed.html) | 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 |
| [shuffle(lst)](https://www.runoob.com/python/func-number-shuffle.html) | 将序列的所有元素随机排序                                     |
| [uniform(x, y)](https://www.runoob.com/python/func-number-uniform.html) | 随机生成下一个实数，它在[x,y]范围内。                        |

## 三角函数：

| 函数                                                         | 描述                                              |
| :----------------------------------------------------------- | :------------------------------------------------ |
| [acos(x)](https://www.runoob.com/python/func-number-acos.html) | 返回x的反余弦弧度值。                             |
| [asin(x)](https://www.runoob.com/python/func-number-asin.html) | 返回x的反正弦弧度值。                             |
| [atan(x)](https://www.runoob.com/python/func-number-atan.html) | 返回x的反正切弧度值。                             |
| [atan2(y, x)](https://www.runoob.com/python/func-number-atan2.html) | 返回给定的 X 及 Y 坐标值的反正切值。              |
| [cos(x)](https://www.runoob.com/python/func-number-cos.html) | 返回x的弧度的余弦值。                             |
| [hypot(x, y)](https://www.runoob.com/python/func-number-hypot.html) | 返回欧几里德范数 sqrt(x*x + y*y)。                |
| [sin(x)](https://www.runoob.com/python/func-number-sin.html) | 返回的x弧度的正弦值。                             |
| [tan(x)](https://www.runoob.com/python/func-number-tan.html) | 返回x弧度的正切值。                               |
| [degrees(x)](https://www.runoob.com/python/func-number-degrees.html) | 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 |
| [radians(x)](https://www.runoob.com/python/func-number-radians.html) | 将角度转换为弧度                                  |

## 常量：

| 常量 | 描述                                  |
| :--- | :------------------------------------ |
| pi   | 数学常量 pi（圆周率，一般以π来表示）  |
| e    | 数学常量 e，e即自然常数（自然常数）。 |



# 十五、编译过程

词法分析、语法分析、语义检查和中间代码生成、代码优化、目标代码、表格管理、出错处理



# 十六、JVM

## JVM类加载机制



### JVM组成

### ![JVM模型](C:\Users\pc\Desktop\知识累积\JVM模型.png)

类加载器、运行时数据区、执行引擎、本地接口库

#### 类加载器

又称类装载子系统，为编译成功的.class文件装载到运行时数据区的方法区

#### 运行时数据区

包括堆、方法区、<u>栈、本地方法栈、程序计数器</u>

其中，堆和方法区为共享，栈、本地方法栈、程序计数器为每个线程独享

##### 堆

存放new出来的对象（实例对象）

用于存储对象实例，是占用内存最大的区域，可划分为新生代和老年代，新生代又可细分为 Eden区、From Survivor区、To Survivor区。

##### 栈

为每个线程单独分配一块内存区域，存放方法内部的变量、常量等

##### 方法区

存放常量+静态变量+类信息

##### 本地方法栈

本地native方法，由其他语言实现并调用，也是为线程私有

##### 程序计数器

为每个线程分配单独的一块内存区域，存放程序执行的位置，由执行引擎来记录



#### 执行引擎

负责解释class指令，再提交给操作系统执行



#### 本地库接口

与native lib(本地方法库)交互，融合其他编程语言为Java所用，是与其它编程语言交互的接口



### 对象布局

<img src="C:\Users\pc\Desktop\知识累积\对象布局.png" alt="对象布局" style="zoom:150%;" />

在 HotSpot 中，对象在堆内存布局分成三部分：对象头，实例数据，对齐填充。

① 对象头：包括两部分的信息：

运行时数据：存储对象自身的运行数据，如哈希码，GC代年龄，锁状态、线程持有的锁、偏向线程ID等。
类型指针：即对象指向它的类型数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那对象头中还必须有一块用于记录数组长度的数据。
② 实例数据：是对象真正存储的有效信息，是在程序代码中所定义的各种类型的字段内容，相同宽度的字段会被分配到一起。

③ 对齐填充：并不是必然存在的，仅起着占位符的作用


## [JVM垃圾回收](https://www.bilibili.com/video/BV1mD4y1o7kt?p=7&spm_id_from=pageDriver&vd_source=cb5cce1bdc5ab99fce812684e0c31a2b)

![JVM垃圾回收](C:\Users\pc\Desktop\知识累积\JVM垃圾回收.png)

### 垃圾回收算法

https://juejin.cn/post/6844903639794843656

#### 判断是否为垃圾

①引用计数算法

`Java` **堆** 中每个具体对象（**不是引用**）都有一个**引用计数器**。当一个对象被创建并初始化赋值后，该变量计数设置为`1`。每当有一个地方引用它时，计数器值就**加1**。当引用**失效**时，即一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时，计数器值就**减1**。任何引用计数为`0`的对象可以被当作**垃圾收集**。当一个对象被垃圾收集时，它引用的任何对象计数减1。

- **优点**：

  引用计数收集器执行简单，判定效率高，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。

- **缺点**：

  难以检测出对象之间的循环引用。同时，引用计数器增加了程序执行的开销。所以Java语言并没有选择这种算法进行垃圾回收。

②可达性分析算法

**可达性分析算法**也叫**根搜索算法**，通过一系列的称为 `GC Roots` 的对象作为起点，然后向下搜索。搜索所走过的**路径**称为引用链 （`Reference Chain`）， 当一个**对象**到 `GC Roots` 没有任何**引用链**相连时, 即该对象**不可达**，也就说明此对象是 **不可用的**。

如下图所示: `Object5`、`Object6`、`Object7` 虽然互有关联, 但它们到`GC Roots`是不可达的, 因此也会被判定为可回收的对象。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/17/164a85bd8307d805~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



**GC根对象**

在`Java`中, 可作为`GC Roots`的对象包括以下四种：

- **虚拟机栈**（栈帧中的**本地变量表**）中引用的对象

- **本地方法栈** 中 `JNI` （`Native`方法）引用的变量

- **方法区** 中**类静态属性**引用的变量

- **方法区** 中**常量**引用的变量

  JVM中用到的所有现代GC算法在回收前都会先找出所有仍存活的对象。可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图。下图展示的JVM中的内存布局可以用来很好地阐释这一概念：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/17/164a85bd831e2005~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



#### 对象引用类型

**1. 强引用(Strong Reference)**

在代码中普遍存在的，类似`Object obj = new Object()`这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。

**2. 软引用(Sofe Reference)**

**有用但并非必需** 的对象，可用`SoftReference`类来实现软引用。在系统将要发生**内存溢出异常**之前，将会把这些对象列进回收范围之中进行**二次回收**。如果这次回收还没有足够的内存，才会抛出内存溢出异常。

**3. 弱引用(Weak Reference)**

**非必需** 的对象，但它的**强度**比软引用更弱，被弱引用关联的对象**只能**生存到下一次垃圾收集发生之前，`JDK`提供了`WeakReference`类来实现弱引用。无论当前内存是否足够，用软引用相关联的对象都会被回收掉。

**4. 虚引用(Phantom Reference)**

虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系，`JDK`提供了`PhantomReference`类来实现虚引用。为一个对象设置虚引用的唯一目的是：能在这个对象在**垃圾回收器**回收时收到一个**系统通知**。



## 一些调优工具

jvisualvm(命令行指令，jdk自带，可查看java运行时的数据)

阿尔撒斯（阿里的一个开源工具，直接引入架包，运行即可监控当前所有java进程，并可定位出现问题的线程位置、反编译代码等功能）



# 十七、[Linux操作系统的常用终端命令](https://www.runoob.com/linux/linux-command-manual.html)

Linux常用命令全拼：https://www.runoob.com/w3cnote/linux-command-full-fight.html

```shell
# 一、创建目录(-p 表示当前目录路径中有不存在的就自动创建；-m表示设置什么权限)：
mkdir dirname
mkdir -p path1/path2/dirname
mkdir -m 777 dirname

# 二、创建文件(vi/vim/touch/echo/cd)
vi file.txt
touch file.txt
# >:追加
# >>:覆盖
echo "this is a new file" > file.txt
echo "this is a new file" >> file.txt
cd > file.txt
cd >> file.txt

# 三、修改文件权限:https://blog.csdn.net/pythonw/article/details/80263428
# 
# 权限	权限数值	二进制	具体作用
# r	4	00000100	read，读取。当前用户可以读取文件内容，当前用户可以浏览目录。
# w	2	00000010	write，写入。当前用户可以新增或修改文件内容，当前用户可以删除、移动目录或目录内文件。
# x	1	00000001	execute，执行。当前用户可以执行文件，当前用户可以进入目录。
# 
# 依照上面的表格，权限组合就是对应权限值求和，如下：
# 7 = 4 + 2 + 1      读写运行权限
# 5 = 4 + 1             读和运行权限
# 4 = 4                   只读权限
# 
# 读写运行权限付给：文件所有者、群组用户、其他用户
sudo chmod  777 /etc/squid
# 读写权限付给：文件所有者；读和运行权限付给：用户群组；只读权限付给其他用户
sudo chmod  754  filename

# 四、查看文件内容
cat file
# 同时显现file1 file2的内容
cat file1 file2
# 合并file1 file2的内容到文件file中
cat file1 file2 > file

# 五、结束进程
# 先找到进程的PID
pidof XXX
# 得到PID后结束所有PID（假设PID = 2551 2514 1963 1856 1771）
# -9为彻底杀死进程
# -KILL为强制杀手进程
kill -9 2551 2514 1963 1856 1771

# 六、检查8080端口有无被占用
lsof -i:8080

```



# 十八、IO及阻塞

**同步是指:** 发送方发出数据后, 等待接收方发回响应后才发下一个数据包的通讯方式. 就是在发出一个调用时, 在没有得到结果之前, 该调用就不返回, 但是一旦调用返回, 就得到返回值了. 也就是由"调用者"主动等待这个"调用"的结果.

**异步是指:** 发送方发出数据后, 不等待接收方发回响应, 接着发送下个数据包的通讯方式. 当一个异步过程调用发出后, 调用者不会立刻得到结果. 而是在调用发出后, "被调用者"通过状态、通知来通知调用者, 或通过回调函数处理这个调用.

阻塞和非阻塞属于进程API执行动作的方式, 关注的是程序在等待调用结果时的状态.

**阻塞是指:** 调用结果返回之前, 当前线程会被挂起. 函数只有在得到结果之后才会返回, 线程需要等待结果.

**非阻塞是指:** 与阻塞的概念相对应, 指在不能立刻得到结果之前, 该函数不会阻塞当前线程, 而会立刻返回. 线程不需要等待结果.



## BIO

同步阻塞

例子：每次客户端请求服务器时，就会产生一个新的线程，在一个响应处理完之前，客户端那边的请求只能等待响应，什么都做不了。

当大量客户端请求，就会产生大量的线程，造成服务器端过载过高，最后崩溃死掉，底层采用ServerSocket实现。

<img src="https://img-blog.csdnimg.cn/4d50eac8822343b3966cb01b96e4282b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Lya6aOe55qESVTonJfniZs=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" />

## NIO

同步**非阻塞**

NIO是一种基于通道和缓冲区的I/O方式，NIO有三大核心部分：Channel(通道)，Buffer(缓冲区)，Selector（选择器）

客户端发送的请求不会被阻塞，而是直接进入，最多排队等待一段时间，服务器通过一个线程轮询大量的请求channel，每次获取一批有事件的channel，并对每个请求启动线程池中的一个线程进行处理。其核心就是非阻塞，一个客户端并不是时时刻刻都有数据进行交互，没有必要死耗着一个线程不放，所以客户端选择了让线程歇一歇，只有客户端有相应的操作的时候才发起通知，创建一个线程来处理请求。（**理解：相当于每个客户端都有一个channel，服务器从从有事件channel中获取请求，并从线程池中启动线程来进行操作**）

- NIO的优点：每次发起的 IO 系统调用，在内核的等待数据过程中可以立即返回。用户线程不会阻塞，实时性较好。
- NIO的缺点：需要不断的重复发起IO系统调用，这种不断的轮询，将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低。

底层是用ServerSocketChannel来实现的。

<img src="https://img-blog.csdnimg.cn/64249714cdfe47aabe8517898d2d8081.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Lya6aOe55qESVTonJfniZs=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" />N

## AIO

异步非阻塞

基于Proactor模型实现。 每个连接发送过来的请求，都会绑定一个Buffer，然后通知操作系统去完成异步的读，这个时间你就可以去做其他的事情，等到操作系统完成读之后，就会调用你的接口，给你操作系统异步读完的数据。这个时候你就可以拿到数据进行处理，将数据往回写，在往回写的过程，同样是给操作系统一个Buffer，让操作系统去完成写，写完了来通知你。这俩个过程都有buffer存在，数据都是通过buffer来完成读写。

这里面的主要的区别在于将数据写入的缓冲区后，就不去管它，剩下的去交给操作系统去完成。操作系统写回数据也是一样，写到Buffer里面，写完后通知客户端来进行读取数据。

（**理解，相当于每次读和写的数据都指定一个缓冲区（buffer），从缓冲区里读或写道缓冲区里，何时写、何时读都是操作总系统来完成，你在发送请求后就去做自己的事情，等待操作系统的通知**）



<img src="https://img-blog.csdnimg.cn/c50ee54a4d6b4cc79b59517144f03c2f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Lya6aOe55qESVTonJfniZs=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" />



# 十九、[JAVA的锁机制](https://blog.csdn.net/weixin_43911945/article/details/118882959?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-118882959-blog-124181191.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-118882959-blog-124181191.pc_relevant_aa&utm_relevant_index=1)



![image-20210718153610023](https://img-blog.csdnimg.cn/img_convert/f61be61be3b69735d3589a32faa8172c.png)

<img src="https://s2.51cto.com/images/blog/202205/24151237_628c85651c01287623.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="小白也能看懂的锁升级过程和锁状态_sed_04"  />

## 无锁

顾名思义就是没有对资源进行锁定，所有线程都能访问到同一资源。这就涉及到多种情况

无竞争：线程之间不存在竞争直接获取资源就可以了
存在竞争：使用非锁方式实现同步线程。这就是我们耳熟能详的CAS（Compare And Swap）
CAS通过操作系统的一条指令来实现，所以它可以保证原子性，通过诸如CAS这种方式，我们就可以进行无锁编程。

## 偏向锁

 上面我们也分析了依赖操作系统的mutex lock导致性能低下的原因，所以在大部分情况下无锁的效率是很高的，但这并非意味着无锁能全面代替有锁。

 现在我们给对象开始加锁，假如一个对象被加锁了，但在实际运行时只有一个线程会获取这个对象锁。那么我们最理想的情况就是不通过线程状态切换，也不需要通过CAS来获得锁，因为这多多少少还是会耗费一些资源。我们设想的是最好对象能够认识这个线程，只要是这个线程过来，那么对象直接把锁交出去，我们就可以认为这个锁偏爱这个线程，所以被称为偏向锁，那么偏向锁是如何实现的？

再看到这幅Mark Word的图：



我们先通过判断后三位来判断是否是偏向锁，如果是偏向锁的话，它的前23位就是用来记录偏爱的进程ID。

## 轻量级锁

如果对象发现目前不知有一个线程，而是有多个线程正在竞争锁，那么偏向锁就会升级成轻量级锁。

当锁的状态还是偏向锁时，是通过Mark Word中的线程id来找到线程，那么当锁的状态升级到轻量级锁的时候，如何判断线程和锁之间的绑定关系呢？

图中给出了答案：通过前30位来指向栈中锁记录的指针。

我们来具体研究一下：

当一个线程想要获得某个对象的锁时，加入看到锁的标志位为00，那么就知道它是一个轻量级锁。

**这时线程会再自己的虚拟机栈中开辟一块被称为Lock Record的空间。**

关于虚拟机栈，上面JVM内存结构中提到了这是线程私有的。
那么Lock Record存放的是什么呢？存放的是对象头中**Mark Word的副本**，以及**owner指针**

线程通过CAS去尝试获取锁，**一旦获得那么将会赋值该对象头中的Mark Word到Lock Record中，并且将Lock Record中的owner指针指向该对象。**

同时对象的Mark Word的前30位将会生成一个指针，指向虚拟机栈中的Lock Record

这样就完成了线程和对象之间的绑定，他们可以互相知道对方的存在。

完成了线程和对象之间的绑定之后，万一有其他线程也想要获取到这个对象怎么办？

此时其他需要资源的线程将会进入自旋等待（CPU空转）
如果长时间进行自旋对CPU来说是一种浪费，于是出现了**”适应性自旋“**的优化。
适应性自旋

 自旋时间不再固定，而是由上一次在同个锁上的自旋时间以及锁状态，这两个条件来进行决定。

 举个例子：当前正在自旋等待的线程刚刚已经成功获得过了锁，但是锁目前是被其他线程占用，那么虚拟机就会认为这次自旋也很有可能会成功，进而允许更长的自旋时间。

 假如此时有一个线程正在进行自旋，那么这个线程将会进行等待。如果同时有多个线程想要获得这个对象锁，也就是一旦自选等待的线程超过一个，那么轻量级锁将会升级为重量级锁。

## 重量级锁

如果对象锁状态被标记为重量级锁，那么就是和我们最初讲的那样，需要通过Monitor来对线程进行控制，此时将会完全锁定资源，对线程的管控最为严格



## Sychronized

通过javap -c 反编译.calss文件，我们可以发现Sychronized反编译会生成：monitorenter 和 monitorexit两个字节码指令。monitorenter和monitorexit将我们的核心代码进行了包裹。

<img src="https://img-blog.csdnimg.cn/img_convert/ff00ea08c43c0e6e32a05c718493c632.png" alt="image-20210718162704914" style="zoom:50%;" />

synchronized的同步机制

 可以看下上面这张图，首先Entry Set中聚集了一些想要进入Monitor的线程，他们都处于Waiting状态，加入某个名为A的线程成功的进入了Monitor，那么他就处于Active。假设此时线程执行途中遇到了一个判断条件，需要让它暂时让出执行权，它就会进入Wait Set，状态也会标记为waiting，此时Entry Set中的线程B就有机会进入到Monitor。如果线程B进入Monitor中运行完代码之后，它就会通过notify的形式来唤醒Wait Set中的A线程。

synchronized的性能问题

 上面说到synchronized会生成monitorenter和monitorexit两条字节码指令，而Monitor时依赖于操作系统的mutex lock来实现的。Java线程实际上时对操作系统线程的映射，所以**每当唤醒或挂起一个线程的时候，都是在操作系统中的用户态和内核态进行切换**。这种操作时**重量级**的，在一些情况下切换时间甚至会超过线程执行任务的时间，这样的话使用synchronized将会对程序的性能产生严重的影响。


# 二十、redis的线程安全问题

参考资料：https://javaniuniu.com/mianshi/Redis/0705/02



# TODO、一些还未解决的困惑

- [ ] ①进程完成磁盘读取后，内核会干些什么（分配内存？分配cpu？进程就绪？分配时间片？降低优先级？）

  

- [x] ②c++中构造函数和析构函数能不能调用纯虚函数？

  （可以调用虚函数，但是不能纯虚函数，虚函数底层实现原理(但是最好不要在构造和析构函数中调用) 可以，但是没有动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数。 effictive c++第九条，绝不在构造和析构过程中调用virtual,因为构造函数中的base的虚函数不会下降到derived上。而是直接调用base类的虚函数。绝不在构造和析构函数中调用virtual函数：

  - a) 如果有继承，构造函数会先调用父类构造函数，而如果构造函数中有虚函数，此时子类还没有构造，所以此时的对象还是父类的，不会触发多态。更容易记的是基类构造期间，virtual函数不是virtual函数。
  - b) 析构函数也是一样，子类先进行析构，这时，如果有virtual函数的话，子类的内容已经被析构了，C++会视其父类，执行父类的virtual函数。
  - c) 总之，在构造和析构函数中，不要用虚函数。如果必须用，那么分离出一个Init函数和一个close函数，实现相关功能即可）

  

- [x] ③顺序队列和链式队列的性能比较及区别（查找和增添、删除、访问）（**访问多用顺序表，访问少用链表**）

- [x] ④堆到底是指最大堆还是普通堆？？？？？(**堆有两种，最大堆和最小堆，都是有一定顺序（子节点一定比父节点小或者大）的**)

- [x] ⑤hash表能不能存null?（键null?，值null?）（**HashMap对象的key、value值均可为null。Hashtable对象的key、value值均不可为null。且两者的的key值均不能重复，若添加key相同的键值对，后面的value会自动覆盖前面的value，但不会报错。**）

- [x] ⑥if-else if-else到底用什么设计模式优化，解决上千上万行代码的问题？（做出类图，代码实现？难搞）

  （**策略模式**）

- [x] ⑦c中方法定义怎么才算合规，重载的规范（**不可只重载返回类型，必须重载输入参数或其类型**）？（我真的会谢）

- [x] ⑧servelt的生命周期？

  （**Servlet 初始化后调用 init () 方法。**

  **Servlet 调用 service() 方法来处理客户端的请求。**

  **Servlet 销毁前调用 destroy() 方法。**

  **最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。**）
  
- [x] ⑨进程并发（并发执行的特点是使得多个进程在**逻辑上同时执行**，将多个进程的指令轮换执行，表现为多个进程的执行挂起再执行，在宏观上似乎是同时执行了多个进程。）

- [x] ⑩tcp协议如何保证有序（**序列号保证有序，同时进行数据检查有无缺失遗漏**）

- [x] 11.如何区别http和https（HTTP是作用于应用层上的面向无连接状态的协议，而HTTPS是一个建立在HTTP和HTTPS之间的一个加密通信协议，加密HTTP的通信，全称为HTTP over SSL/TLS）

- [x] 12.数据库事务的特性（**原子性、一致性、隔离性、持久性**）

- [x] 13.数据库事务的问题（**脏读、非重复读、幻像读、修改丢失**）

- [x] 14.如何解决数据库事务的问题（**锁来实现，数据库提供了四大隔离级别：未提交读、已提交读、可重复读、串行读**）

- [ ] 15.如何利用数据结构和算法，实现定时器？

- [x] 16.redis如何保证安全？（单线程）

- [ ] 17.docker出错如何排查？

- [ ] 18.高并发场景下，如何保证程序数据保存到redis的线程安全问题？

- [x] 19.多路复用机制是如何支持海量连接？

  ```txt
  NIO的线程模型 对Socket发起的连接不需要每个都创建一个线程，完全可以使用一个Selector来多路复用监听N多个Channel是否有请求，该请求是对应的连接请求，还是发送数据的请求，这里面是基于操作系统底层的Select通知机制的，一个Selector不断的轮询多个Channel，这样避免了创建多个线程，只有当某个Channel有对应的请求的时候才会创建线程，可能说1000个请求， 只有100个请求是有数据交互的， 这个时候可能server端就提供10个线程就能够处理这些请求。这样的话就可以避免了创建大量的线程。
  ```

- [x] [20.java对象生成过程](https://juejin.cn/post/7157864552242085924)

​		类加载器

​		分配内存（指针碰撞、空闲列表）

​		初始化零值

​		设置对象头

​		执行init方法

- [x] 21.对象的布局

​		在 Hotspot 虚拟机中，对象在堆内存中的布局可以分为 3 块区域：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。

​		对象头

​		实例数据

​		对齐填充
